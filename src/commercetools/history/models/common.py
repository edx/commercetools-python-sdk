# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType

__all__ = [
    "Address",
    "Asset",
    "AssetDimensions",
    "AssetSource",
    "Associate",
    "AssociateRoleAssignment",
    "AssociateRoleInheritanceMode",
    "AttributeConstraintEnum",
    "AttributeDefinition",
    "AttributeLocalizedEnumValue",
    "AttributePlainEnumValue",
    "AttributeType",
    "AuthenticationMode",
    "BusinessUnitAssociateMode",
    "BusinessUnitStatus",
    "BusinessUnitStoreMode",
    "CategoryOrderHints",
    "ChannelRoleEnum",
    "CustomFields",
    "CustomLineItem",
    "Delivery",
    "DeliveryItem",
    "DiscountCodeInfo",
    "DiscountCodeState",
    "DiscountedLineItemPortion",
    "DiscountedLineItemPrice",
    "DiscountedLineItemPriceForQuantity",
    "FieldDefinition",
    "FieldType",
    "GeoLocation",
    "Image",
    "ImageDimensions",
    "InheritedAssociate",
    "InheritedAssociateRoleAssignment",
    "ItemShippingDetails",
    "ItemShippingTarget",
    "ItemState",
    "KeyReference",
    "LineItem",
    "LocalizedString",
    "Location",
    "Money",
    "MoneyType",
    "OrderState",
    "Parcel",
    "ParcelMeasurements",
    "PaymentInfo",
    "PaymentState",
    "Permission",
    "Price",
    "ProductSelectionSetting",
    "ProductVariantAvailability",
    "ProductVariantChannelAvailability",
    "ProductVariantChannelAvailabilityMap",
    "ProductVariantSelection",
    "ProductVariantSelectionTypeEnum",
    "QuoteRequestState",
    "QuoteState",
    "Reference",
    "ReferenceTypeId",
    "Reservation",
    "ResourceIdentifier",
    "ReturnInfo",
    "ReturnItem",
    "ReturnPaymentState",
    "ReturnShipmentState",
    "ReviewRatingStatistics",
    "RoundingMode",
    "SearchKeyword",
    "SearchKeywords",
    "SelectionMode",
    "ShipmentState",
    "ShippingRate",
    "ShippingRatePriceTier",
    "ShippingRateTierType",
    "StackingMode",
    "StagedQuoteState",
    "StateRoleEnum",
    "StateTypeEnum",
    "StoreCountry",
    "SubRate",
    "SuggestTokenizer",
    "SyncInfo",
    "TaxCalculationMode",
    "TaxMode",
    "TaxRate",
    "TaxedItemPrice",
    "TaxedPrice",
    "TextInputHint",
    "TextLineItem",
    "TrackingData",
    "Transaction",
    "TransactionState",
    "TransactionType",
    "Variant",
]


class LocalizedString(typing.Dict[str, str]):
    pass


class Address(_BaseType):
    #: Unique ID of the Address.
    id: str
    key: str
    title: str
    salutation: str
    first_name: str
    last_name: str
    street_name: str
    street_number: str
    additional_street_info: str
    postal_code: str
    city: str
    region: str
    state: str
    #: Two-digit country code as per [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2).
    country: str
    company: str
    department: str
    building: str
    apartment: str
    p_o_box: str
    phone: str
    mobile: str
    email: str
    fax: str
    additional_address_info: str
    external_id: str

    def __init__(
        self,
        *,
        id: str,
        key: str,
        title: str,
        salutation: str,
        first_name: str,
        last_name: str,
        street_name: str,
        street_number: str,
        additional_street_info: str,
        postal_code: str,
        city: str,
        region: str,
        state: str,
        country: str,
        company: str,
        department: str,
        building: str,
        apartment: str,
        p_o_box: str,
        phone: str,
        mobile: str,
        email: str,
        fax: str,
        additional_address_info: str,
        external_id: str
    ):
        self.id = id
        self.key = key
        self.title = title
        self.salutation = salutation
        self.first_name = first_name
        self.last_name = last_name
        self.street_name = street_name
        self.street_number = street_number
        self.additional_street_info = additional_street_info
        self.postal_code = postal_code
        self.city = city
        self.region = region
        self.state = state
        self.country = country
        self.company = company
        self.department = department
        self.building = building
        self.apartment = apartment
        self.p_o_box = p_o_box
        self.phone = phone
        self.mobile = mobile
        self.email = email
        self.fax = fax
        self.additional_address_info = additional_address_info
        self.external_id = external_id

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Address":
        from ._schemas.common import AddressSchema

        return AddressSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import AddressSchema

        return AddressSchema().dump(self)


class Asset(_BaseType):
    id: str
    name: "LocalizedString"
    description: "LocalizedString"
    custom: "CustomFields"
    key: str

    def __init__(
        self,
        *,
        id: str,
        name: "LocalizedString",
        description: "LocalizedString",
        custom: "CustomFields",
        key: str
    ):
        self.id = id
        self.name = name
        self.description = description
        self.custom = custom
        self.key = key

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Asset":
        from ._schemas.common import AssetSchema

        return AssetSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import AssetSchema

        return AssetSchema().dump(self)


class AssetDimensions(_BaseType):
    w: int
    h: int

    def __init__(self, *, w: int, h: int):
        self.w = w
        self.h = h

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AssetDimensions":
        from ._schemas.common import AssetDimensionsSchema

        return AssetDimensionsSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import AssetDimensionsSchema

        return AssetDimensionsSchema().dump(self)


class AssetSource(_BaseType):
    uri: str
    key: str
    dimensions: "AssetDimensions"
    content_type: str

    def __init__(
        self, *, uri: str, key: str, dimensions: "AssetDimensions", content_type: str
    ):
        self.uri = uri
        self.key = key
        self.dimensions = dimensions
        self.content_type = content_type

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AssetSource":
        from ._schemas.common import AssetSourceSchema

        return AssetSourceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import AssetSourceSchema

        return AssetSourceSchema().dump(self)


class Associate(_BaseType):
    associate_role_assignments: typing.List["AssociateRoleAssignment"]
    customer: "Reference"

    def __init__(
        self,
        *,
        associate_role_assignments: typing.List["AssociateRoleAssignment"],
        customer: "Reference"
    ):
        self.associate_role_assignments = associate_role_assignments
        self.customer = customer

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Associate":
        from ._schemas.common import AssociateSchema

        return AssociateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import AssociateSchema

        return AssociateSchema().dump(self)


class AssociateRoleAssignment(_BaseType):
    associate_role: "KeyReference"
    #: Determines whether an [AssociateRoleAssignment](ctp:api:type:AssociateRoleAssignment) can be inherited by child Business Units.
    inheritance: "AssociateRoleInheritanceMode"

    def __init__(
        self,
        *,
        associate_role: "KeyReference",
        inheritance: "AssociateRoleInheritanceMode"
    ):
        self.associate_role = associate_role
        self.inheritance = inheritance

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "AssociateRoleAssignment":
        from ._schemas.common import AssociateRoleAssignmentSchema

        return AssociateRoleAssignmentSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import AssociateRoleAssignmentSchema

        return AssociateRoleAssignmentSchema().dump(self)


class AssociateRoleInheritanceMode(enum.Enum):
    """Determines whether an [AssociateRoleAssignment](ctp:api:type:AssociateRoleAssignment) can be inherited by child Business Units."""

    ENABLED = "Enabled"
    DISABLED = "Disabled"


class AttributeConstraintEnum(enum.Enum):
    NONE = "None"
    UNIQUE = "Unique"
    COMBINATION_UNIQUE = "CombinationUnique"
    SAME_FOR_ALL = "SameForAll"


class AttributeDefinition(_BaseType):
    type: "AttributeType"
    #: The unique name of the attribute used in the API. The name must be between two and 256 characters long and can contain the ASCII letters A to Z in lowercase or uppercase, digits, underscores (`_`) and the hyphen-minus (`-`). When using the same `name` for an attribute in two or more product types all fields of the AttributeDefinition of this attribute need to be the same across the product types, otherwise an AttributeDefinitionAlreadyExists error code will be returned. An exception to this are the values of an `enum` or `lenum` type and sets thereof.
    name: str
    label: "LocalizedString"
    #: Whether the attribute is required to have a value.
    is_required: bool
    attribute_constraint: "AttributeConstraintEnum"
    input_tip: "LocalizedString"
    input_hint: "TextInputHint"
    #: Whether the attribute's values should generally be enabled in product search. This determines whether the value is stored in products for matching terms in the context of full-text search queries  and can be used in facets & filters as part of product search queries. The exact features that are enabled/disabled with this flag depend on the concrete attribute type and are described there. The max size of a searchable field is **restricted to 10922 characters**. This constraint is enforced at both product creation and product update. If the length of the input exceeds the maximum size an InvalidField error is returned.
    is_searchable: bool

    def __init__(
        self,
        *,
        type: "AttributeType",
        name: str,
        label: "LocalizedString",
        is_required: bool,
        attribute_constraint: "AttributeConstraintEnum",
        input_tip: "LocalizedString",
        input_hint: "TextInputHint",
        is_searchable: bool
    ):
        self.type = type
        self.name = name
        self.label = label
        self.is_required = is_required
        self.attribute_constraint = attribute_constraint
        self.input_tip = input_tip
        self.input_hint = input_hint
        self.is_searchable = is_searchable

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AttributeDefinition":
        from ._schemas.common import AttributeDefinitionSchema

        return AttributeDefinitionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import AttributeDefinitionSchema

        return AttributeDefinitionSchema().dump(self)


class AttributeLocalizedEnumValue(_BaseType):
    """A localized enum value must be unique within the enum, else a [DuplicateEnumValues](ctp:api:type:DuplicateEnumValuesError) error is returned."""

    #: Key of the value used as a programmatic identifier, for example in facets & filters.
    key: str
    #: Descriptive, localized label of the value.
    label: "LocalizedString"

    def __init__(self, *, key: str, label: "LocalizedString"):
        self.key = key
        self.label = label

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "AttributeLocalizedEnumValue":
        from ._schemas.common import AttributeLocalizedEnumValueSchema

        return AttributeLocalizedEnumValueSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import AttributeLocalizedEnumValueSchema

        return AttributeLocalizedEnumValueSchema().dump(self)


class AttributePlainEnumValue(_BaseType):
    """A plain enum value must be unique within the enum, else a [DuplicateEnumValues](ctp:api:type:DuplicateEnumValuesError) error is returned."""

    #: Key of the value used as a programmatic identifier, for example in facets & filters.
    key: str
    #: Descriptive label of the value.
    label: str

    def __init__(self, *, key: str, label: str):
        self.key = key
        self.label = label

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "AttributePlainEnumValue":
        from ._schemas.common import AttributePlainEnumValueSchema

        return AttributePlainEnumValueSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import AttributePlainEnumValueSchema

        return AttributePlainEnumValueSchema().dump(self)


class AttributeType(_BaseType):
    name: str

    def __init__(self, *, name: str):
        self.name = name

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AttributeType":
        from ._schemas.common import AttributeTypeSchema

        return AttributeTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import AttributeTypeSchema

        return AttributeTypeSchema().dump(self)


class AuthenticationMode(enum.Enum):
    PASSWORD = "Password"
    EXTERNAL_AUTH = "ExternalAuth"


class BusinessUnitAssociateMode(enum.Enum):
    """Determines whether a Business Unit can inherit Associates from a parent."""

    EXPLICIT = "Explicit"
    EXPLICIT_AND_FROM_PARENT = "ExplicitAndFromParent"


class BusinessUnitStatus(enum.Enum):
    """Indicates whether the Business Unit can be edited and used in [Carts](ctp:api:type:Cart), [Orders](ctp:api:type:Order), [Quote Requests](ctp:api:type:QuoteRequest), or [Quotes](ctp:api:type:Quote)."""

    ACTIVE = "Active"
    INACTIVE = "Inactive"


class BusinessUnitStoreMode(enum.Enum):
    """Defines whether the Stores of the Business Unit are set directly on the Business Unit or are inherited from its parent unit."""

    EXPLICIT = "Explicit"
    FROM_PARENT = "FromParent"


class CategoryOrderHints(typing.Dict[str, str]):
    pass


class ChannelRoleEnum(enum.Enum):
    """Describes the purpose and type of the Channel. A Channel can have one or more roles."""

    INVENTORY_SUPPLY = "InventorySupply"
    PRODUCT_DISTRIBUTION = "ProductDistribution"
    ORDER_EXPORT = "OrderExport"
    ORDER_IMPORT = "OrderImport"
    PRIMARY = "Primary"


class CustomFields(_BaseType):
    type: "Reference"
    #: A valid JSON object, based on FieldDefinition.
    fields: object

    def __init__(self, *, type: "Reference", fields: object):
        self.type = type
        self.fields = fields

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomFields":
        from ._schemas.common import CustomFieldsSchema

        return CustomFieldsSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import CustomFieldsSchema

        return CustomFieldsSchema().dump(self)


class CustomLineItem(_BaseType):
    #: The unique ID of this CustomLineItem.
    id: str
    name: "LocalizedString"
    money: "Money"
    taxed_price: "TaxedItemPrice"
    total_price: "Money"
    #: A unique String in the cart to identify this CustomLineItem.
    slug: str
    #: The amount of a CustomLineItem in the cart. Must be a positive integer.
    quantity: int

    def __init__(
        self,
        *,
        id: str,
        name: "LocalizedString",
        money: "Money",
        taxed_price: "TaxedItemPrice",
        total_price: "Money",
        slug: str,
        quantity: int
    ):
        self.id = id
        self.name = name
        self.money = money
        self.taxed_price = taxed_price
        self.total_price = total_price
        self.slug = slug
        self.quantity = quantity

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomLineItem":
        from ._schemas.common import CustomLineItemSchema

        return CustomLineItemSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import CustomLineItemSchema

        return CustomLineItemSchema().dump(self)


class Delivery(_BaseType):
    id: str
    created_at: str
    items: typing.List["DeliveryItem"]
    parcels: typing.List["Parcel"]
    address: typing.Optional["Address"]
    #: Custom Fields for the Transaction.
    custom: typing.Optional["CustomFields"]

    def __init__(
        self,
        *,
        id: str,
        created_at: str,
        items: typing.List["DeliveryItem"],
        parcels: typing.List["Parcel"],
        address: typing.Optional["Address"] = None,
        custom: typing.Optional["CustomFields"] = None
    ):
        self.id = id
        self.created_at = created_at
        self.items = items
        self.parcels = parcels
        self.address = address
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Delivery":
        from ._schemas.common import DeliverySchema

        return DeliverySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import DeliverySchema

        return DeliverySchema().dump(self)


class DeliveryItem(_BaseType):
    id: str
    quantity: int

    def __init__(self, *, id: str, quantity: int):
        self.id = id
        self.quantity = quantity

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DeliveryItem":
        from ._schemas.common import DeliveryItemSchema

        return DeliveryItemSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import DeliveryItemSchema

        return DeliveryItemSchema().dump(self)


class DiscountCodeInfo(_BaseType):
    discount_code: "Reference"
    state: "DiscountCodeState"

    def __init__(self, *, discount_code: "Reference", state: "DiscountCodeState"):
        self.discount_code = discount_code
        self.state = state

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DiscountCodeInfo":
        from ._schemas.common import DiscountCodeInfoSchema

        return DiscountCodeInfoSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import DiscountCodeInfoSchema

        return DiscountCodeInfoSchema().dump(self)


class DiscountCodeState(enum.Enum):
    NOT_ACTIVE = "NotActive"
    DOES_NOT_MATCH_CART = "DoesNotMatchCart"
    MATCHES_CART = "MatchesCart"
    MAX_APPLICATION_REACHED = "MaxApplicationReached"
    APPLICATION_STOPPED_BY_PREVIOUS_DISCOUNT = "ApplicationStoppedByPreviousDiscount"
    NOT_VALID = "NotValid"


class DiscountedLineItemPortion(_BaseType):
    discount: "Reference"
    discounted_amount: "Money"

    def __init__(self, *, discount: "Reference", discounted_amount: "Money"):
        self.discount = discount
        self.discounted_amount = discounted_amount

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountedLineItemPortion":
        from ._schemas.common import DiscountedLineItemPortionSchema

        return DiscountedLineItemPortionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import DiscountedLineItemPortionSchema

        return DiscountedLineItemPortionSchema().dump(self)


class DiscountedLineItemPrice(_BaseType):
    value: "Money"
    included_discounts: typing.List["DiscountedLineItemPortion"]

    def __init__(
        self,
        *,
        value: "Money",
        included_discounts: typing.List["DiscountedLineItemPortion"]
    ):
        self.value = value
        self.included_discounts = included_discounts

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountedLineItemPrice":
        from ._schemas.common import DiscountedLineItemPriceSchema

        return DiscountedLineItemPriceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import DiscountedLineItemPriceSchema

        return DiscountedLineItemPriceSchema().dump(self)


class DiscountedLineItemPriceForQuantity(_BaseType):
    quantity: int
    discounted_price: "DiscountedLineItemPrice"

    def __init__(self, *, quantity: int, discounted_price: "DiscountedLineItemPrice"):
        self.quantity = quantity
        self.discounted_price = discounted_price

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountedLineItemPriceForQuantity":
        from ._schemas.common import DiscountedLineItemPriceForQuantitySchema

        return DiscountedLineItemPriceForQuantitySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import DiscountedLineItemPriceForQuantitySchema

        return DiscountedLineItemPriceForQuantitySchema().dump(self)


class FieldDefinition(_BaseType):
    type: "FieldType"
    #: The name of the field. The name must be between two and 36 characters long and can contain the ASCII letters A to Z in lowercase or uppercase, digits, underscores (`_`) and the hyphen-minus (`-`). The name must be unique for a given resource type ID. In case there is a field with the same name in another type it has to have the same FieldType also.
    name: str
    label: "LocalizedString"
    input_hint: "TextInputHint"

    def __init__(
        self,
        *,
        type: "FieldType",
        name: str,
        label: "LocalizedString",
        input_hint: "TextInputHint"
    ):
        self.type = type
        self.name = name
        self.label = label
        self.input_hint = input_hint

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "FieldDefinition":
        from ._schemas.common import FieldDefinitionSchema

        return FieldDefinitionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import FieldDefinitionSchema

        return FieldDefinitionSchema().dump(self)


class FieldType(_BaseType):
    name: str

    def __init__(self, *, name: str):
        self.name = name

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "FieldType":
        from ._schemas.common import FieldTypeSchema

        return FieldTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import FieldTypeSchema

        return FieldTypeSchema().dump(self)


class GeoLocation(_BaseType):
    type: str
    coordinates: typing.List["int"]

    def __init__(self, *, type: str, coordinates: typing.List["int"]):
        self.type = type
        self.coordinates = coordinates

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "GeoLocation":
        from ._schemas.common import GeoLocationSchema

        return GeoLocationSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import GeoLocationSchema

        return GeoLocationSchema().dump(self)


class Image(_BaseType):
    url: str
    dimensions: "ImageDimensions"
    label: str

    def __init__(self, *, url: str, dimensions: "ImageDimensions", label: str):
        self.url = url
        self.dimensions = dimensions
        self.label = label

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Image":
        from ._schemas.common import ImageSchema

        return ImageSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ImageSchema

        return ImageSchema().dump(self)


class ImageDimensions(_BaseType):
    w: int
    h: int

    def __init__(self, *, w: int, h: int):
        self.w = w
        self.h = h

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ImageDimensions":
        from ._schemas.common import ImageDimensionsSchema

        return ImageDimensionsSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ImageDimensionsSchema

        return ImageDimensionsSchema().dump(self)


class InheritedAssociate(_BaseType):
    associate_role_assignments: typing.List["InheritedAssociateRoleAssignment"]
    customer: "Reference"

    def __init__(
        self,
        *,
        associate_role_assignments: typing.List["InheritedAssociateRoleAssignment"],
        customer: "Reference"
    ):
        self.associate_role_assignments = associate_role_assignments
        self.customer = customer

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "InheritedAssociate":
        from ._schemas.common import InheritedAssociateSchema

        return InheritedAssociateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import InheritedAssociateSchema

        return InheritedAssociateSchema().dump(self)


class InheritedAssociateRoleAssignment(_BaseType):
    associate_role: "KeyReference"
    source: "KeyReference"

    def __init__(self, *, associate_role: "KeyReference", source: "KeyReference"):
        self.associate_role = associate_role
        self.source = source

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "InheritedAssociateRoleAssignment":
        from ._schemas.common import InheritedAssociateRoleAssignmentSchema

        return InheritedAssociateRoleAssignmentSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import InheritedAssociateRoleAssignmentSchema

        return InheritedAssociateRoleAssignmentSchema().dump(self)


class ItemShippingDetails(_BaseType):
    targets: typing.List["ItemShippingTarget"]
    #: true if the quantity of the (custom) line item is equal to the sum of the sub-quantities in `targets`, `false` otherwise. A cart cannot be ordered when the value is `false`. The error InvalidItemShippingDetails will be triggered.
    valid: bool

    def __init__(self, *, targets: typing.List["ItemShippingTarget"], valid: bool):
        self.targets = targets
        self.valid = valid

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ItemShippingDetails":
        from ._schemas.common import ItemShippingDetailsSchema

        return ItemShippingDetailsSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ItemShippingDetailsSchema

        return ItemShippingDetailsSchema().dump(self)


class ItemShippingTarget(_BaseType):
    #: The key of the address in the cart's `itemShippingAddresses`
    address_key: str
    #: The quantity of items that should go to the address with the specified `addressKey`. Only positive values are allowed. Using `0` as quantity is also possible in a draft object, but the element will not be present in the resulting ItemShippingDetails.
    quantity: int

    def __init__(self, *, address_key: str, quantity: int):
        self.address_key = address_key
        self.quantity = quantity

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ItemShippingTarget":
        from ._schemas.common import ItemShippingTargetSchema

        return ItemShippingTargetSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ItemShippingTargetSchema

        return ItemShippingTargetSchema().dump(self)


class ItemState(_BaseType):
    quantity: int
    state: "Reference"

    def __init__(self, *, quantity: int, state: "Reference"):
        self.quantity = quantity
        self.state = state

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ItemState":
        from ._schemas.common import ItemStateSchema

        return ItemStateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ItemStateSchema

        return ItemStateSchema().dump(self)


class KeyReference(_BaseType):
    key: str
    type_id: "ReferenceTypeId"

    def __init__(self, *, key: str, type_id: "ReferenceTypeId"):
        self.key = key
        self.type_id = type_id

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "KeyReference":
        from ._schemas.common import KeyReferenceSchema

        return KeyReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import KeyReferenceSchema

        return KeyReferenceSchema().dump(self)


class LineItem(_BaseType):
    added_at: str
    custom: "CustomFields"
    id: str
    name: "LocalizedString"
    product_id: str
    product_slug: "LocalizedString"
    product_type: "Reference"
    quantity: int
    variant: "Variant"
    variant_id: int

    def __init__(
        self,
        *,
        added_at: str,
        custom: "CustomFields",
        id: str,
        name: "LocalizedString",
        product_id: str,
        product_slug: "LocalizedString",
        product_type: "Reference",
        quantity: int,
        variant: "Variant",
        variant_id: int
    ):
        self.added_at = added_at
        self.custom = custom
        self.id = id
        self.name = name
        self.product_id = product_id
        self.product_slug = product_slug
        self.product_type = product_type
        self.quantity = quantity
        self.variant = variant
        self.variant_id = variant_id

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "LineItem":
        from ._schemas.common import LineItemSchema

        return LineItemSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import LineItemSchema

        return LineItemSchema().dump(self)


class Location(_BaseType):
    """Shape of the value for `addLocation` and `removeLocation` actions"""

    #: Two-digit country code as per [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2).
    country: str
    state: str

    def __init__(self, *, country: str, state: str):
        self.country = country
        self.state = state

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Location":
        from ._schemas.common import LocationSchema

        return LocationSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import LocationSchema

        return LocationSchema().dump(self)


class Money(_BaseType):
    #: Currency code compliant to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
    currency_code: str
    cent_amount: int
    fraction_digits: int
    type: "MoneyType"

    def __init__(
        self,
        *,
        currency_code: str,
        cent_amount: int,
        fraction_digits: int,
        type: "MoneyType"
    ):
        self.currency_code = currency_code
        self.cent_amount = cent_amount
        self.fraction_digits = fraction_digits
        self.type = type

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Money":
        from ._schemas.common import MoneySchema

        return MoneySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import MoneySchema

        return MoneySchema().dump(self)


class MoneyType(enum.Enum):
    CENT_PRECISION = "centPrecision"
    HIGH_PRECISION = "highPrecision"


class OrderState(enum.Enum):
    OPEN = "Open"
    CONFIRMED = "Confirmed"
    COMPLETE = "Complete"
    CANCELLED = "Cancelled"


class Parcel(_BaseType):
    id: str
    created_at: str
    measurements: "ParcelMeasurements"
    tracking_data: "TrackingData"
    items: typing.List["DeliveryItem"]

    def __init__(
        self,
        *,
        id: str,
        created_at: str,
        measurements: "ParcelMeasurements",
        tracking_data: "TrackingData",
        items: typing.List["DeliveryItem"]
    ):
        self.id = id
        self.created_at = created_at
        self.measurements = measurements
        self.tracking_data = tracking_data
        self.items = items

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Parcel":
        from ._schemas.common import ParcelSchema

        return ParcelSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ParcelSchema

        return ParcelSchema().dump(self)


class ParcelMeasurements(_BaseType):
    height_in_millimeter: int
    length_in_millimeter: int
    width_in_millimeter: int
    weight_in_gram: int

    def __init__(
        self,
        *,
        height_in_millimeter: int,
        length_in_millimeter: int,
        width_in_millimeter: int,
        weight_in_gram: int
    ):
        self.height_in_millimeter = height_in_millimeter
        self.length_in_millimeter = length_in_millimeter
        self.width_in_millimeter = width_in_millimeter
        self.weight_in_gram = weight_in_gram

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ParcelMeasurements":
        from ._schemas.common import ParcelMeasurementsSchema

        return ParcelMeasurementsSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ParcelMeasurementsSchema

        return ParcelMeasurementsSchema().dump(self)


class PaymentInfo(_BaseType):
    payments: typing.List["Reference"]

    def __init__(self, *, payments: typing.List["Reference"]):
        self.payments = payments

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "PaymentInfo":
        from ._schemas.common import PaymentInfoSchema

        return PaymentInfoSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import PaymentInfoSchema

        return PaymentInfoSchema().dump(self)


class PaymentState(enum.Enum):
    BALANCE_DUE = "BalanceDue"
    FAILED = "Failed"
    PENDING = "Pending"
    CREDIT_OWED = "CreditOwed"
    PAID = "Paid"


class Permission(enum.Enum):
    """Permissions grant granular access to [Business Units](ctp:api:type:BusinessUnit), [Carts](ctp:api:type:Cart), [Orders](ctp:api:type:Order), [Quotes](ctp:api:type:Quote), and [Quote Requests](ctp:api:type:QuoteRequest)."""

    ADD_CHILD_UNITS = "AddChildUnits"
    UPDATE_ASSOCIATES = "UpdateAssociates"
    UPDATE_BUSINESS_UNIT_DETAILS = "UpdateBusinessUnitDetails"
    UPDATE_PARENT_UNIT = "UpdateParentUnit"
    VIEW_MY_CARTS = "ViewMyCarts"
    VIEW_OTHERS_CARTS = "ViewOthersCarts"
    UPDATE_MY_CARTS = "UpdateMyCarts"
    UPDATE_OTHERS_CARTS = "UpdateOthersCarts"
    CREATE_MY_CARTS = "CreateMyCarts"
    CREATE_OTHERS_CARTS = "CreateOthersCarts"
    DELETE_MY_CARTS = "DeleteMyCarts"
    DELETE_OTHERS_CARTS = "DeleteOthersCarts"
    VIEW_MY_ORDERS = "ViewMyOrders"
    VIEW_OTHERS_ORDERS = "ViewOthersOrders"
    UPDATE_MY_ORDERS = "UpdateMyOrders"
    UPDATE_OTHERS_ORDERS = "UpdateOthersOrders"
    CREATE_MY_ORDERS_FROM_MY_CARTS = "CreateMyOrdersFromMyCarts"
    CREATE_MY_ORDERS_FROM_MY_QUOTES = "CreateMyOrdersFromMyQuotes"
    CREATE_ORDERS_FROM_OTHERS_CARTS = "CreateOrdersFromOthersCarts"
    CREATE_ORDERS_FROM_OTHERS_QUOTES = "CreateOrdersFromOthersQuotes"
    VIEW_MY_QUOTES = "ViewMyQuotes"
    VIEW_OTHERS_QUOTES = "ViewOthersQuotes"
    ACCEPT_MY_QUOTES = "AcceptMyQuotes"
    ACCEPT_OTHERS_QUOTES = "AcceptOthersQuotes"
    DECLINE_MY_QUOTES = "DeclineMyQuotes"
    DECLINE_OTHERS_QUOTES = "DeclineOthersQuotes"
    RENEGOTIATE_MY_QUOTES = "RenegotiateMyQuotes"
    RENEGOTIATE_OTHERS_QUOTES = "RenegotiateOthersQuotes"
    REASSIGN_MY_QUOTES = "ReassignMyQuotes"
    REASSIGN_OTHERS_QUOTES = "ReassignOthersQuotes"
    VIEW_MY_QUOTE_REQUESTS = "ViewMyQuoteRequests"
    VIEW_OTHERS_QUOTE_REQUESTS = "ViewOthersQuoteRequests"
    UPDATE_MY_QUOTE_REQUESTS = "UpdateMyQuoteRequests"
    UPDATE_OTHERS_QUOTE_REQUESTS = "UpdateOthersQuoteRequests"
    CREATE_MY_QUOTE_REQUESTS_FROM_MY_CARTS = "CreateMyQuoteRequestsFromMyCarts"
    CREATE_QUOTE_REQUESTS_FROM_OTHERS_CARTS = "CreateQuoteRequestsFromOthersCarts"


class Price(_BaseType):
    id: str
    value: "Money"

    def __init__(self, *, id: str, value: "Money"):
        self.id = id
        self.value = value

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Price":
        from ._schemas.common import PriceSchema

        return PriceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import PriceSchema

        return PriceSchema().dump(self)


class ProductSelectionSetting(_BaseType):
    product_selection: "Reference"
    active: bool

    def __init__(self, *, product_selection: "Reference", active: bool):
        self.product_selection = product_selection
        self.active = active

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSelectionSetting":
        from ._schemas.common import ProductSelectionSettingSchema

        return ProductSelectionSettingSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ProductSelectionSettingSchema

        return ProductSelectionSettingSchema().dump(self)


class ProductVariantAvailability(_BaseType):
    is_on_stock: bool
    restockable_in_days: int
    available_quantity: int
    channels: "ProductVariantChannelAvailabilityMap"

    def __init__(
        self,
        *,
        is_on_stock: bool,
        restockable_in_days: int,
        available_quantity: int,
        channels: "ProductVariantChannelAvailabilityMap"
    ):
        self.is_on_stock = is_on_stock
        self.restockable_in_days = restockable_in_days
        self.available_quantity = available_quantity
        self.channels = channels

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductVariantAvailability":
        from ._schemas.common import ProductVariantAvailabilitySchema

        return ProductVariantAvailabilitySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ProductVariantAvailabilitySchema

        return ProductVariantAvailabilitySchema().dump(self)


class ProductVariantChannelAvailability(_BaseType):
    is_on_stock: bool
    restockable_in_days: int
    available_quantity: int

    def __init__(
        self, *, is_on_stock: bool, restockable_in_days: int, available_quantity: int
    ):
        self.is_on_stock = is_on_stock
        self.restockable_in_days = restockable_in_days
        self.available_quantity = available_quantity

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductVariantChannelAvailability":
        from ._schemas.common import ProductVariantChannelAvailabilitySchema

        return ProductVariantChannelAvailabilitySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ProductVariantChannelAvailabilitySchema

        return ProductVariantChannelAvailabilitySchema().dump(self)


class ProductVariantChannelAvailabilityMap(
    typing.Dict[str, "ProductVariantChannelAvailability"]
):
    pass


class ProductVariantSelection(_BaseType):
    type: "ProductVariantSelectionTypeEnum"
    skus: typing.List["str"]

    def __init__(
        self, *, type: "ProductVariantSelectionTypeEnum", skus: typing.List["str"]
    ):
        self.type = type
        self.skus = skus

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductVariantSelection":
        from ._schemas.common import ProductVariantSelectionSchema

        return ProductVariantSelectionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ProductVariantSelectionSchema

        return ProductVariantSelectionSchema().dump(self)


class ProductVariantSelectionTypeEnum(enum.Enum):
    INCLUSION = "inclusion"
    EXCLUSION = "exclusion"


class QuoteRequestState(enum.Enum):
    SUBMITTED = "Submitted"
    ACCEPTED = "Accepted"
    CLOSED = "Closed"
    REJECTED = "Rejected"
    CANCELLED = "Cancelled"


class QuoteState(enum.Enum):
    PENDING = "Pending"
    DECLINED = "Declined"
    DECLINED_FOR_RENEGOTIATION = "DeclinedForRenegotiation"
    ACCEPTED = "Accepted"
    FAILED = "Failed"
    WITHDRAWN = "Withdrawn"


class Reference(_BaseType):
    id: str
    type_id: "ReferenceTypeId"

    def __init__(self, *, id: str, type_id: "ReferenceTypeId"):
        self.id = id
        self.type_id = type_id

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Reference":
        from ._schemas.common import ReferenceSchema

        return ReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ReferenceSchema

        return ReferenceSchema().dump(self)


class ReferenceTypeId(enum.Enum):
    ASSOCIATE_ROLE = "associate-role"
    BUSINESS_UNIT = "business-unit"
    CART = "cart"
    CART_DISCOUNT = "cart-discount"
    CATEGORY = "category"
    CHANNEL = "channel"
    CUSTOMER = "customer"
    CUSTOMER_EMAIL_TOKEN = "customer-email-token"
    CUSTOMER_GROUP = "customer-group"
    CUSTOMER_PASSWORD_TOKEN = "customer-password-token"
    DISCOUNT_CODE = "discount-code"
    EXTENSION = "extension"
    INVENTORY_ENTRY = "inventory-entry"
    KEY_VALUE_DOCUMENT = "key-value-document"
    ORDER = "order"
    ORDER_EDIT = "order-edit"
    PAYMENT = "payment"
    PRODUCT = "product"
    PRODUCT_DISCOUNT = "product-discount"
    PRODUCT_SELECTION = "product-selection"
    PRODUCT_TYPE = "product-type"
    QUOTE = "quote"
    QUOTE_REQUEST = "quote-request"
    REVIEW = "review"
    SHIPPING_METHOD = "shipping-method"
    SHOPPING_LIST = "shopping-list"
    STAGED_QUOTE = "staged-quote"
    STATE = "state"
    STORE = "store"
    SUBSCRIPTION = "subscription"
    TAX_CATEGORY = "tax-category"
    TYPE = "type"
    ZONE = "zone"


class Reservation(_BaseType):
    quantity: int
    owner: "Reference"
    created_at: str
    checkout_started_at: str

    def __init__(
        self,
        *,
        quantity: int,
        owner: "Reference",
        created_at: str,
        checkout_started_at: str
    ):
        self.quantity = quantity
        self.owner = owner
        self.created_at = created_at
        self.checkout_started_at = checkout_started_at

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Reservation":
        from ._schemas.common import ReservationSchema

        return ReservationSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ReservationSchema

        return ReservationSchema().dump(self)


class ResourceIdentifier(_BaseType):
    id: str
    key: str
    type_id: "ReferenceTypeId"

    def __init__(self, *, id: str, key: str, type_id: "ReferenceTypeId"):
        self.id = id
        self.key = key
        self.type_id = type_id

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ResourceIdentifier":
        from ._schemas.common import ResourceIdentifierSchema

        return ResourceIdentifierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ResourceIdentifierSchema

        return ResourceIdentifierSchema().dump(self)


class ReturnInfo(_BaseType):
    items: typing.List["ReturnItem"]
    #: Identifies, which return tracking ID is connected to this particular return.
    return_tracking_id: str
    return_date: str

    def __init__(
        self,
        *,
        items: typing.List["ReturnItem"],
        return_tracking_id: str,
        return_date: str
    ):
        self.items = items
        self.return_tracking_id = return_tracking_id
        self.return_date = return_date

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ReturnInfo":
        from ._schemas.common import ReturnInfoSchema

        return ReturnInfoSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ReturnInfoSchema

        return ReturnInfoSchema().dump(self)


class ReturnItem(_BaseType):
    id: str
    quantity: int
    type: str
    comment: str
    shipment_state: "ReturnShipmentState"
    payment_state: "ReturnPaymentState"
    last_modified_at: str
    created_at: str

    def __init__(
        self,
        *,
        id: str,
        quantity: int,
        type: str,
        comment: str,
        shipment_state: "ReturnShipmentState",
        payment_state: "ReturnPaymentState",
        last_modified_at: str,
        created_at: str
    ):
        self.id = id
        self.quantity = quantity
        self.type = type
        self.comment = comment
        self.shipment_state = shipment_state
        self.payment_state = payment_state
        self.last_modified_at = last_modified_at
        self.created_at = created_at

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ReturnItem":
        from ._schemas.common import ReturnItemSchema

        return ReturnItemSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ReturnItemSchema

        return ReturnItemSchema().dump(self)


class ReturnPaymentState(enum.Enum):
    NON_REFUNDABLE = "NonRefundable"
    INITIAL = "Initial"
    REFUNDED = "Refunded"
    NOT_REFUNDED = "NotRefunded"


class ReturnShipmentState(enum.Enum):
    ADVISED = "Advised"
    RETURNED = "Returned"
    BACK_IN_STOCK = "BackInStock"
    UNUSABLE = "Unusable"


class ReviewRatingStatistics(_BaseType):
    #: Average rating of one target This number is rounded with 5 decimals.
    average_rating: int
    #: Highest rating of one target
    highest_rating: int
    #: Lowest rating of one target
    lowest_rating: int
    #: Number of ratings taken into account
    count: int
    #: The full distribution of the ratings. The keys are the different ratings and the values are the count of reviews having this rating. Only the used ratings appear in this object.
    ratings_distribution: object

    def __init__(
        self,
        *,
        average_rating: int,
        highest_rating: int,
        lowest_rating: int,
        count: int,
        ratings_distribution: object
    ):
        self.average_rating = average_rating
        self.highest_rating = highest_rating
        self.lowest_rating = lowest_rating
        self.count = count
        self.ratings_distribution = ratings_distribution

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ReviewRatingStatistics":
        from ._schemas.common import ReviewRatingStatisticsSchema

        return ReviewRatingStatisticsSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ReviewRatingStatisticsSchema

        return ReviewRatingStatisticsSchema().dump(self)


class RoundingMode(enum.Enum):
    HALF_EVEN = "HalfEven"
    HALF_UP = "HalfUp"
    HALF_DOWN = "HalfDown"


class SearchKeyword(_BaseType):
    text: str
    suggest_tokenizer: "SuggestTokenizer"

    def __init__(self, *, text: str, suggest_tokenizer: "SuggestTokenizer"):
        self.text = text
        self.suggest_tokenizer = suggest_tokenizer

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "SearchKeyword":
        from ._schemas.common import SearchKeywordSchema

        return SearchKeywordSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import SearchKeywordSchema

        return SearchKeywordSchema().dump(self)


class SearchKeywords(typing.Dict[str, typing.List["SearchKeyword"]]):
    pass


class SelectionMode(enum.Enum):
    CHEAPEST = "Cheapest"
    MOST_EXPENSIVE = "MostExpensive"


class ShipmentState(enum.Enum):
    SHIPPED = "Shipped"
    READY = "Ready"
    PENDING = "Pending"
    DELAYED = "Delayed"
    PARTIAL = "Partial"
    BACKORDER = "Backorder"


class ShippingRate(_BaseType):
    price: "Money"
    free_above: "Money"
    #: Only appears in response to requests for ShippingMethods by Cart or location to mark this shipping rate as one that matches the Cart or location.
    is_matching: bool
    tiers: typing.List["ShippingRatePriceTier"]

    def __init__(
        self,
        *,
        price: "Money",
        free_above: "Money",
        is_matching: bool,
        tiers: typing.List["ShippingRatePriceTier"]
    ):
        self.price = price
        self.free_above = free_above
        self.is_matching = is_matching
        self.tiers = tiers

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ShippingRate":
        from ._schemas.common import ShippingRateSchema

        return ShippingRateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ShippingRateSchema

        return ShippingRateSchema().dump(self)


class ShippingRatePriceTier(_BaseType):
    type: "ShippingRateTierType"

    def __init__(self, *, type: "ShippingRateTierType"):
        self.type = type

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ShippingRatePriceTier":
        from ._schemas.common import ShippingRatePriceTierSchema

        return ShippingRatePriceTierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ShippingRatePriceTierSchema

        return ShippingRatePriceTierSchema().dump(self)


class ShippingRateTierType(enum.Enum):
    CART_VALUE = "CartValue"
    CART_CLASSIFICATION = "CartClassification"
    CART_SCORE = "CartScore"


class StackingMode(enum.Enum):
    STACKING = "Stacking"
    STOP_AFTER_THIS_DISCOUNT = "StopAfterThisDiscount"


class StagedQuoteState(enum.Enum):
    IN_PROGRESS = "InProgress"
    SENT = "Sent"
    CLOSED = "Closed"


class StateRoleEnum(enum.Enum):
    """For some resource types, a State can fulfill the following predefined roles:"""

    REVIEW_INCLUDED_IN_STATISTICS = "ReviewIncludedInStatistics"
    RETURN = "Return"


class StateTypeEnum(enum.Enum):
    """Resource or object type the State can be assigned to."""

    ORDER_STATE = "OrderState"
    LINE_ITEM_STATE = "LineItemState"
    PRODUCT_STATE = "ProductState"
    REVIEW_STATE = "ReviewState"
    PAYMENT_STATE = "PaymentState"
    QUOTE_REQUEST_STATE = "QuoteRequestState"
    STAGED_QUOTE_STATE = "StagedQuoteState"
    QUOTE_STATE = "QuoteState"


class StoreCountry(_BaseType):
    #: Two-digit country code as per [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2).
    code: str

    def __init__(self, *, code: str):
        self.code = code

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "StoreCountry":
        from ._schemas.common import StoreCountrySchema

        return StoreCountrySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import StoreCountrySchema

        return StoreCountrySchema().dump(self)


class SubRate(_BaseType):
    name: str
    amount: int

    def __init__(self, *, name: str, amount: int):
        self.name = name
        self.amount = amount

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "SubRate":
        from ._schemas.common import SubRateSchema

        return SubRateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import SubRateSchema

        return SubRateSchema().dump(self)


class SuggestTokenizer(_BaseType):
    type: str

    def __init__(self, *, type: str):
        self.type = type

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "SuggestTokenizer":
        from ._schemas.common import SuggestTokenizerSchema

        return SuggestTokenizerSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import SuggestTokenizerSchema

        return SuggestTokenizerSchema().dump(self)


class SyncInfo(_BaseType):
    channel: "Reference"
    #: Can be used to reference an external order instance, file etc.
    external_id: str
    synced_at: str

    def __init__(self, *, channel: "Reference", external_id: str, synced_at: str):
        self.channel = channel
        self.external_id = external_id
        self.synced_at = synced_at

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "SyncInfo":
        from ._schemas.common import SyncInfoSchema

        return SyncInfoSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import SyncInfoSchema

        return SyncInfoSchema().dump(self)


class TaxCalculationMode(enum.Enum):
    LINE_ITEM_LEVEL = "LineItemLevel"
    UNIT_PRICE_LEVEL = "UnitPriceLevel"


class TaxMode(enum.Enum):
    PLATFORM = "Platform"
    EXTERNAL = "External"
    EXTERNAL_AMOUNT = "ExternalAmount"
    DISABLED = "Disabled"


class TaxRate(_BaseType):
    """Shape of the value for `addTaxRate` and `removeTaxRate` actions"""

    #: The ID is always set if the tax rate is part of a TaxCategory. The external tax rates in a Cart do not contain an `id`.
    id: str
    name: str
    #: Percentage in the range of [0..1]. The sum of the amounts of all `subRates`, if there are any.
    amount: int
    included_in_price: bool
    #: Two-digit country code as per [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2).
    country: str
    #: The state in the country
    state: str
    sub_rates: typing.List["SubRate"]

    def __init__(
        self,
        *,
        id: str,
        name: str,
        amount: int,
        included_in_price: bool,
        country: str,
        state: str,
        sub_rates: typing.List["SubRate"]
    ):
        self.id = id
        self.name = name
        self.amount = amount
        self.included_in_price = included_in_price
        self.country = country
        self.state = state
        self.sub_rates = sub_rates

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TaxRate":
        from ._schemas.common import TaxRateSchema

        return TaxRateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import TaxRateSchema

        return TaxRateSchema().dump(self)


class TaxedItemPrice(_BaseType):
    total_net: "Money"
    total_gross: "Money"

    def __init__(self, *, total_net: "Money", total_gross: "Money"):
        self.total_net = total_net
        self.total_gross = total_gross

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TaxedItemPrice":
        from ._schemas.common import TaxedItemPriceSchema

        return TaxedItemPriceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import TaxedItemPriceSchema

        return TaxedItemPriceSchema().dump(self)


class TaxedPrice(_BaseType):
    #: Total net price of the Order.
    total_net: "Money"
    #: Total gross price of the Order.
    total_gross: "Money"

    def __init__(self, *, total_net: "Money", total_gross: "Money"):
        self.total_net = total_net
        self.total_gross = total_gross

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TaxedPrice":
        from ._schemas.common import TaxedPriceSchema

        return TaxedPriceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import TaxedPriceSchema

        return TaxedPriceSchema().dump(self)


class TextInputHint(enum.Enum):
    SINGLE_LINE = "SingleLine"
    MULTI_LINE = "MultiLine"


class TextLineItem(_BaseType):
    added_at: str
    custom: "CustomFields"
    description: "LocalizedString"
    id: str
    name: "LocalizedString"
    quantity: int

    def __init__(
        self,
        *,
        added_at: str,
        custom: "CustomFields",
        description: "LocalizedString",
        id: str,
        name: "LocalizedString",
        quantity: int
    ):
        self.added_at = added_at
        self.custom = custom
        self.description = description
        self.id = id
        self.name = name
        self.quantity = quantity

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TextLineItem":
        from ._schemas.common import TextLineItemSchema

        return TextLineItemSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import TextLineItemSchema

        return TextLineItemSchema().dump(self)


class TrackingData(_BaseType):
    #: The ID to track one parcel.
    tracking_id: str
    #: The carrier that delivers the parcel.
    carrier: str
    provider: str
    provider_transaction: str
    #: Flag to distinguish if the parcel is on the way to the customer (false) or on the way back (true).
    is_return: bool

    def __init__(
        self,
        *,
        tracking_id: str,
        carrier: str,
        provider: str,
        provider_transaction: str,
        is_return: bool
    ):
        self.tracking_id = tracking_id
        self.carrier = carrier
        self.provider = provider
        self.provider_transaction = provider_transaction
        self.is_return = is_return

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TrackingData":
        from ._schemas.common import TrackingDataSchema

        return TrackingDataSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import TrackingDataSchema

        return TrackingDataSchema().dump(self)


class Transaction(_BaseType):
    #: Unique identifier of the Transaction.
    id: str
    #: Time at which the transaction took place.
    timestamp: str
    type: "TransactionType"
    amount: "Money"
    #: Identifier used by the interface that manages the transaction (usually the PSP). If a matching interaction was logged in the `interfaceInteractions` array, the corresponding interaction should be findable with this ID.
    interaction_id: str
    state: "TransactionState"

    def __init__(
        self,
        *,
        id: str,
        timestamp: str,
        type: "TransactionType",
        amount: "Money",
        interaction_id: str,
        state: "TransactionState"
    ):
        self.id = id
        self.timestamp = timestamp
        self.type = type
        self.amount = amount
        self.interaction_id = interaction_id
        self.state = state

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Transaction":
        from ._schemas.common import TransactionSchema

        return TransactionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import TransactionSchema

        return TransactionSchema().dump(self)


class TransactionState(enum.Enum):
    INITIAL = "Initial"
    PENDING = "Pending"
    SUCCESS = "Success"
    FAILURE = "Failure"


class TransactionType(enum.Enum):
    AUTHORIZATION = "Authorization"
    CANCEL_AUTHORIZATION = "CancelAuthorization"
    CHARGE = "Charge"
    REFUND = "Refund"
    CHARGEBACK = "Chargeback"


class Variant(_BaseType):
    id: int
    sku: str
    key: str

    def __init__(self, *, id: int, sku: str, key: str):
        self.id = id
        self.sku = sku
        self.key = key

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Variant":
        from ._schemas.common import VariantSchema

        return VariantSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import VariantSchema

        return VariantSchema().dump(self)
