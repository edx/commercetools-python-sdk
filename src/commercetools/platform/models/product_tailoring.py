# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .common import BaseResource, Reference, ReferenceTypeId, ResourceIdentifier

if typing.TYPE_CHECKING:
    from .common import (
        Asset,
        AssetDraft,
        AssetSource,
        CreatedBy,
        Image,
        LastModifiedBy,
        LocalizedString,
        ReferenceTypeId,
    )
    from .product import ProductReference, ProductResourceIdentifier
    from .store import StoreKeyReference, StoreResourceIdentifier
    from .type import FieldContainer, TypeResourceIdentifier

__all__ = [
    "ProductTailoring",
    "ProductTailoringAddAssetAction",
    "ProductTailoringAddExternalImageAction",
    "ProductTailoringAddVariantAction",
    "ProductTailoringChangeAssetNameAction",
    "ProductTailoringChangeAssetOrderAction",
    "ProductTailoringData",
    "ProductTailoringDraft",
    "ProductTailoringInStoreDraft",
    "ProductTailoringMoveImageToPositionAction",
    "ProductTailoringPagedQueryResponse",
    "ProductTailoringPublishAction",
    "ProductTailoringReference",
    "ProductTailoringRemoveAssetAction",
    "ProductTailoringRemoveImageAction",
    "ProductTailoringRemoveVariantAction",
    "ProductTailoringResourceIdentifier",
    "ProductTailoringSetAssetCustomFieldAction",
    "ProductTailoringSetAssetCustomTypeAction",
    "ProductTailoringSetAssetDescriptionAction",
    "ProductTailoringSetAssetKeyAction",
    "ProductTailoringSetAssetSourcesAction",
    "ProductTailoringSetAssetTagsAction",
    "ProductTailoringSetDescriptionAction",
    "ProductTailoringSetExternalImagesAction",
    "ProductTailoringSetImageLabelAction",
    "ProductTailoringSetMetaAttributesAction",
    "ProductTailoringSetMetaDescriptionAction",
    "ProductTailoringSetMetaKeywordsAction",
    "ProductTailoringSetMetaTitleAction",
    "ProductTailoringSetNameAction",
    "ProductTailoringSetSlugAction",
    "ProductTailoringUnpublishAction",
    "ProductTailoringUpdateAction",
    "ProductVariantTailoring",
    "ProductVariantTailoringDraft",
]


class ProductTailoring(BaseResource):
    """A single ProductTailoring representation contains the _current_ and the _staged_ representation of its product data tailored per Store."""

    #: IDs and references that last modified the ProductTailoring.
    last_modified_by: typing.Optional["LastModifiedBy"]
    #: IDs and references that created the ProductTailoring.
    created_by: typing.Optional["CreatedBy"]
    #: User-defined unique identifier of the ProductTailoring.
    key: typing.Optional[str]
    #: The Store to which the ProductTailoring belongs.
    store: "StoreKeyReference"
    #: Reference to the Product the ProductTailoring belongs to.
    product: "ProductReference"
    #: `true` if the ProductTailoring is published.
    published: bool
    #: Current (published) data of the ProductTailoring.
    current: "ProductTailoringData"
    #: Staged (unpublished) data of the ProductTailoring.
    staged: "ProductTailoringData"
    #: `true` if the `staged` data is different from the `current` data.
    has_staged_changes: bool

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None,
        key: typing.Optional[str] = None,
        store: "StoreKeyReference",
        product: "ProductReference",
        published: bool,
        current: "ProductTailoringData",
        staged: "ProductTailoringData",
        has_staged_changes: bool
    ):
        self.last_modified_by = last_modified_by
        self.created_by = created_by
        self.key = key
        self.store = store
        self.product = product
        self.published = published
        self.current = current
        self.staged = staged
        self.has_staged_changes = has_staged_changes

        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductTailoring":
        from ._schemas.product_tailoring import ProductTailoringSchema

        return ProductTailoringSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringSchema

        return ProductTailoringSchema().dump(self)


class ProductTailoringData(_BaseType):
    """Contains all the tailored data of a Product."""

    #: Tailored name of the Product.
    name: typing.Optional["LocalizedString"]
    #: Tailored description of the Product.
    description: typing.Optional["LocalizedString"]
    #: Tailored title of the Product used by external search engines for improved search engine performance.
    meta_title: typing.Optional["LocalizedString"]
    #: Tailored description of the Product used by external search engines for improved search engine performance.
    meta_description: typing.Optional["LocalizedString"]
    #: Tailored keywords related to the Product used by external search engines for improved search engine performance.
    meta_keywords: typing.Optional["LocalizedString"]
    #: User-defined identifier used in a deep-link URL for the ProductTailoring.
    #: Matches the pattern `[a-zA-Z0-9_\\-]{2,256}`.
    slug: typing.Optional["LocalizedString"]
    #: Tailored Variants of the Product.
    variants: typing.Optional[typing.List["ProductVariantTailoring"]]

    def __init__(
        self,
        *,
        name: typing.Optional["LocalizedString"] = None,
        description: typing.Optional["LocalizedString"] = None,
        meta_title: typing.Optional["LocalizedString"] = None,
        meta_description: typing.Optional["LocalizedString"] = None,
        meta_keywords: typing.Optional["LocalizedString"] = None,
        slug: typing.Optional["LocalizedString"] = None,
        variants: typing.Optional[typing.List["ProductVariantTailoring"]] = None
    ):
        self.name = name
        self.description = description
        self.meta_title = meta_title
        self.meta_description = meta_description
        self.meta_keywords = meta_keywords
        self.slug = slug
        self.variants = variants

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductTailoringData":
        from ._schemas.product_tailoring import ProductTailoringDataSchema

        return ProductTailoringDataSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringDataSchema

        return ProductTailoringDataSchema().dump(self)


class ProductTailoringDraft(_BaseType):
    """Contains all the tailored data of a Product."""

    #: User-defined unique identifier of the ProductTailoring.
    key: typing.Optional[str]
    #: The Store to which the ProductTailoring belongs.
    store: "StoreResourceIdentifier"
    #: ResourceIdentifier of the Product the ProductTailoring belongs to.
    product: "ProductResourceIdentifier"
    #: Tailored name of the Product.
    name: typing.Optional["LocalizedString"]
    #: Tailored description of the Product.
    description: typing.Optional["LocalizedString"]
    #: Tailored title of the Product used by external search engines for improved search engine performance.
    meta_title: typing.Optional["LocalizedString"]
    #: Tailored description of the Product used by external search engines for improved search engine performance.
    meta_description: typing.Optional["LocalizedString"]
    #: Tailored keywords related to the Product used by external search engines for improved search engine performance.
    meta_keywords: typing.Optional["LocalizedString"]
    #: User-defined identifier used in a deep-link URL for the ProductTailoring.
    #: Matches the pattern `[a-zA-Z0-9_\\-]{2,256}`.
    slug: typing.Optional["LocalizedString"]
    #: If `true`, the ProductTailoring is published immediately.
    publish: typing.Optional[bool]
    #: Tailored Variants of the Product.
    variants: typing.Optional[typing.List["ProductVariantTailoringDraft"]]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        store: "StoreResourceIdentifier",
        product: "ProductResourceIdentifier",
        name: typing.Optional["LocalizedString"] = None,
        description: typing.Optional["LocalizedString"] = None,
        meta_title: typing.Optional["LocalizedString"] = None,
        meta_description: typing.Optional["LocalizedString"] = None,
        meta_keywords: typing.Optional["LocalizedString"] = None,
        slug: typing.Optional["LocalizedString"] = None,
        publish: typing.Optional[bool] = None,
        variants: typing.Optional[typing.List["ProductVariantTailoringDraft"]] = None
    ):
        self.key = key
        self.store = store
        self.product = product
        self.name = name
        self.description = description
        self.meta_title = meta_title
        self.meta_description = meta_description
        self.meta_keywords = meta_keywords
        self.slug = slug
        self.publish = publish
        self.variants = variants

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductTailoringDraft":
        from ._schemas.product_tailoring import ProductTailoringDraftSchema

        return ProductTailoringDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringDraftSchema

        return ProductTailoringDraftSchema().dump(self)


class ProductTailoringInStoreDraft(_BaseType):
    """Contains all the tailored data of a Product for a specific Store."""

    #: User-defined unique identifier of the ProductTailoring.
    key: typing.Optional[str]
    #: ResourceIdentifier of the Product the ProductTailoring belongs to.
    product: "ProductResourceIdentifier"
    #: Tailored name of the Product.
    name: typing.Optional["LocalizedString"]
    #: Tailored description of the Product.
    description: typing.Optional["LocalizedString"]
    #: Tailored title of the Product used by external search engines for improved search engine performance.
    meta_title: typing.Optional["LocalizedString"]
    #: Tailored description of the Product used by external search engines for improved search engine performance.
    meta_description: typing.Optional["LocalizedString"]
    #: Tailored keywords related to the Product used by external search engines for improved search engine performance.
    meta_keywords: typing.Optional["LocalizedString"]
    #: User-defined identifier used in a deep-link URL for the ProductTailoring.
    #: Matches the pattern `[a-zA-Z0-9_\\-]{2,256}`.
    slug: typing.Optional["LocalizedString"]
    #: If `true`, the ProductTailoring is published immediately.
    publish: typing.Optional[bool]
    #: Tailored Variants of the Product.
    variants: typing.Optional[typing.List["ProductVariantTailoringDraft"]]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        product: "ProductResourceIdentifier",
        name: typing.Optional["LocalizedString"] = None,
        description: typing.Optional["LocalizedString"] = None,
        meta_title: typing.Optional["LocalizedString"] = None,
        meta_description: typing.Optional["LocalizedString"] = None,
        meta_keywords: typing.Optional["LocalizedString"] = None,
        slug: typing.Optional["LocalizedString"] = None,
        publish: typing.Optional[bool] = None,
        variants: typing.Optional[typing.List["ProductVariantTailoringDraft"]] = None
    ):
        self.key = key
        self.product = product
        self.name = name
        self.description = description
        self.meta_title = meta_title
        self.meta_description = meta_description
        self.meta_keywords = meta_keywords
        self.slug = slug
        self.publish = publish
        self.variants = variants

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringInStoreDraft":
        from ._schemas.product_tailoring import ProductTailoringInStoreDraftSchema

        return ProductTailoringInStoreDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringInStoreDraftSchema

        return ProductTailoringInStoreDraftSchema().dump(self)


class ProductTailoringPagedQueryResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) with results containing an array of [ProductTailoring](ctp:api:type:ProductTailoring)."""

    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](/../api/predicates/query), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    #: [ProductTailoring](ctp:api:type:ProductTailoring) list matching the query.
    results: typing.List["ProductTailoring"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: typing.Optional[int] = None,
        results: typing.List["ProductTailoring"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringPagedQueryResponse":
        from ._schemas.product_tailoring import ProductTailoringPagedQueryResponseSchema

        return ProductTailoringPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringPagedQueryResponseSchema

        return ProductTailoringPagedQueryResponseSchema().dump(self)


class ProductTailoringReference(Reference):
    """[Reference](ctp:api:type:Reference) to a [ProductTailoring](ctp:api:type:ProductTailoring)."""

    #: Contains the representation of the expanded ProductTailoring. Only present in responses to requests with [Reference Expansion](/../api/general-concepts#reference-expansion) for ProductTailoring.
    obj: typing.Optional["ProductTailoring"]

    def __init__(self, *, id: str, obj: typing.Optional["ProductTailoring"] = None):
        self.obj = obj

        super().__init__(id=id, type_id=ReferenceTypeId.PRODUCT_TAILORING)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringReference":
        from ._schemas.product_tailoring import ProductTailoringReferenceSchema

        return ProductTailoringReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringReferenceSchema

        return ProductTailoringReferenceSchema().dump(self)


class ProductTailoringResourceIdentifier(ResourceIdentifier):
    """[ResourceIdentifier](ctp:api:type:ResourceIdentifier) to a [ProductTailoring](ctp:api:type:ProductTailoring)."""

    def __init__(
        self, *, id: typing.Optional[str] = None, key: typing.Optional[str] = None
    ):

        super().__init__(id=id, key=key, type_id=ReferenceTypeId.PRODUCT_TAILORING)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringResourceIdentifier":
        from ._schemas.product_tailoring import ProductTailoringResourceIdentifierSchema

        return ProductTailoringResourceIdentifierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringResourceIdentifierSchema

        return ProductTailoringResourceIdentifierSchema().dump(self)


class ProductTailoringUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringUpdateAction":
        if data["action"] == "addAsset":
            from ._schemas.product_tailoring import ProductTailoringAddAssetActionSchema

            return ProductTailoringAddAssetActionSchema().load(data)
        if data["action"] == "addExternalImage":
            from ._schemas.product_tailoring import (
                ProductTailoringAddExternalImageActionSchema,
            )

            return ProductTailoringAddExternalImageActionSchema().load(data)
        if data["action"] == "addVariant":
            from ._schemas.product_tailoring import (
                ProductTailoringAddVariantActionSchema,
            )

            return ProductTailoringAddVariantActionSchema().load(data)
        if data["action"] == "changeAssetName":
            from ._schemas.product_tailoring import (
                ProductTailoringChangeAssetNameActionSchema,
            )

            return ProductTailoringChangeAssetNameActionSchema().load(data)
        if data["action"] == "changeAssetOrder":
            from ._schemas.product_tailoring import (
                ProductTailoringChangeAssetOrderActionSchema,
            )

            return ProductTailoringChangeAssetOrderActionSchema().load(data)
        if data["action"] == "moveImageToPosition":
            from ._schemas.product_tailoring import (
                ProductTailoringMoveImageToPositionActionSchema,
            )

            return ProductTailoringMoveImageToPositionActionSchema().load(data)
        if data["action"] == "publish":
            from ._schemas.product_tailoring import ProductTailoringPublishActionSchema

            return ProductTailoringPublishActionSchema().load(data)
        if data["action"] == "removeAsset":
            from ._schemas.product_tailoring import (
                ProductTailoringRemoveAssetActionSchema,
            )

            return ProductTailoringRemoveAssetActionSchema().load(data)
        if data["action"] == "removeImage":
            from ._schemas.product_tailoring import (
                ProductTailoringRemoveImageActionSchema,
            )

            return ProductTailoringRemoveImageActionSchema().load(data)
        if data["action"] == "removeVariant":
            from ._schemas.product_tailoring import (
                ProductTailoringRemoveVariantActionSchema,
            )

            return ProductTailoringRemoveVariantActionSchema().load(data)
        if data["action"] == "setAssetCustomField":
            from ._schemas.product_tailoring import (
                ProductTailoringSetAssetCustomFieldActionSchema,
            )

            return ProductTailoringSetAssetCustomFieldActionSchema().load(data)
        if data["action"] == "setAssetCustomType":
            from ._schemas.product_tailoring import (
                ProductTailoringSetAssetCustomTypeActionSchema,
            )

            return ProductTailoringSetAssetCustomTypeActionSchema().load(data)
        if data["action"] == "setAssetDescription":
            from ._schemas.product_tailoring import (
                ProductTailoringSetAssetDescriptionActionSchema,
            )

            return ProductTailoringSetAssetDescriptionActionSchema().load(data)
        if data["action"] == "setAssetKey":
            from ._schemas.product_tailoring import (
                ProductTailoringSetAssetKeyActionSchema,
            )

            return ProductTailoringSetAssetKeyActionSchema().load(data)
        if data["action"] == "setAssetSources":
            from ._schemas.product_tailoring import (
                ProductTailoringSetAssetSourcesActionSchema,
            )

            return ProductTailoringSetAssetSourcesActionSchema().load(data)
        if data["action"] == "setAssetTags":
            from ._schemas.product_tailoring import (
                ProductTailoringSetAssetTagsActionSchema,
            )

            return ProductTailoringSetAssetTagsActionSchema().load(data)
        if data["action"] == "setDescription":
            from ._schemas.product_tailoring import (
                ProductTailoringSetDescriptionActionSchema,
            )

            return ProductTailoringSetDescriptionActionSchema().load(data)
        if data["action"] == "setImages":
            from ._schemas.product_tailoring import (
                ProductTailoringSetExternalImagesActionSchema,
            )

            return ProductTailoringSetExternalImagesActionSchema().load(data)
        if data["action"] == "setImageLabel":
            from ._schemas.product_tailoring import (
                ProductTailoringSetImageLabelActionSchema,
            )

            return ProductTailoringSetImageLabelActionSchema().load(data)
        if data["action"] == "setMetaAttributes":
            from ._schemas.product_tailoring import (
                ProductTailoringSetMetaAttributesActionSchema,
            )

            return ProductTailoringSetMetaAttributesActionSchema().load(data)
        if data["action"] == "setMetaDescription":
            from ._schemas.product_tailoring import (
                ProductTailoringSetMetaDescriptionActionSchema,
            )

            return ProductTailoringSetMetaDescriptionActionSchema().load(data)
        if data["action"] == "setMetaKeywords":
            from ._schemas.product_tailoring import (
                ProductTailoringSetMetaKeywordsActionSchema,
            )

            return ProductTailoringSetMetaKeywordsActionSchema().load(data)
        if data["action"] == "setMetaTitle":
            from ._schemas.product_tailoring import (
                ProductTailoringSetMetaTitleActionSchema,
            )

            return ProductTailoringSetMetaTitleActionSchema().load(data)
        if data["action"] == "setName":
            from ._schemas.product_tailoring import ProductTailoringSetNameActionSchema

            return ProductTailoringSetNameActionSchema().load(data)
        if data["action"] == "setSlug":
            from ._schemas.product_tailoring import ProductTailoringSetSlugActionSchema

            return ProductTailoringSetSlugActionSchema().load(data)
        if data["action"] == "unpublish":
            from ._schemas.product_tailoring import (
                ProductTailoringUnpublishActionSchema,
            )

            return ProductTailoringUnpublishActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringUpdateActionSchema

        return ProductTailoringUpdateActionSchema().dump(self)


class ProductVariantTailoring(_BaseType):
    """The tailoring of a [ProductVariant](ctp:api:type:ProductVariant)."""

    #: The `id` of the tailored [ProductVariant](ctp:api:type:ProductVariant).
    id: int
    #: Images of the tailored Product Variant.
    #: If present, these images will override the images of the corresponding [ProductVariant](ctp:api:type:ProductVariant) in total.
    images: typing.Optional[typing.List["Image"]]
    #: Media assets of the tailored Product Variant.
    #: If present, these assets will override the assets of the corresponding [ProductVariant](ctp:api:type:ProductVariant) in total.
    assets: typing.Optional[typing.List["Asset"]]

    def __init__(
        self,
        *,
        id: int,
        images: typing.Optional[typing.List["Image"]] = None,
        assets: typing.Optional[typing.List["Asset"]] = None
    ):
        self.id = id
        self.images = images
        self.assets = assets

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductVariantTailoring":
        from ._schemas.product_tailoring import ProductVariantTailoringSchema

        return ProductVariantTailoringSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductVariantTailoringSchema

        return ProductVariantTailoringSchema().dump(self)


class ProductVariantTailoringDraft(_BaseType):
    """Either `id` or `sku` is required to reference a [ProductVariant](ctp:api:type:ProductVariant) that exists."""

    #: The `id` of the [ProductVariant](ctp:api:type:ProductVariant) to be tailored.
    id: typing.Optional[int]
    #: The `sku` of the [ProductVariant](ctp:api:type:ProductVariant) to be tailored.
    sku: typing.Optional[str]
    #: Images of the tailored Product Variant.
    images: typing.Optional[typing.List["Image"]]
    #: Media assets of the tailored Product Variant.
    assets: typing.Optional[typing.List["Asset"]]

    def __init__(
        self,
        *,
        id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        images: typing.Optional[typing.List["Image"]] = None,
        assets: typing.Optional[typing.List["Asset"]] = None
    ):
        self.id = id
        self.sku = sku
        self.images = images
        self.assets = assets

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductVariantTailoringDraft":
        from ._schemas.product_tailoring import ProductVariantTailoringDraftSchema

        return ProductVariantTailoringDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductVariantTailoringDraftSchema

        return ProductVariantTailoringDraftSchema().dump(self)


class ProductTailoringAddAssetAction(ProductTailoringUpdateAction):
    """Either `variantId` or `sku` is required to reference a [ProductVariant](ctp:api:type:ProductVariant) that exists."""

    #: The `id` of the tailored ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the tailored ProductVariant to update.
    sku: typing.Optional[str]
    #: If `true`, only the staged `assets` are updated. If `false`, both the current and staged `assets` are updated.
    staged: typing.Optional[bool]
    #: Value to append.
    asset: "AssetDraft"
    #: Position in `assets` where the Asset should be put. When specified, the value must be between `0` and the total number of Assets minus `1`.
    position: typing.Optional[int]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None,
        asset: "AssetDraft",
        position: typing.Optional[int] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged
        self.asset = asset
        self.position = position

        super().__init__(action="addAsset")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringAddAssetAction":
        from ._schemas.product_tailoring import ProductTailoringAddAssetActionSchema

        return ProductTailoringAddAssetActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringAddAssetActionSchema

        return ProductTailoringAddAssetActionSchema().dump(self)


class ProductTailoringAddExternalImageAction(ProductTailoringUpdateAction):
    """Either `variantId` or `sku` is required to reference a [ProductVariant](ctp:api:type:ProductVariant) that exists. Produces the [ProductTailoringImageAdded](/projects/messages#product-tailoring-image-added) Message."""

    #: The `id` of the tailored ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the tailored ProductVariant to update.
    sku: typing.Optional[str]
    #: Value to add to `images`.
    image: "Image"
    #: If `true`, only the staged `images` is updated. If `false`, both the current and staged `images` is updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        image: "Image",
        staged: typing.Optional[bool] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.image = image
        self.staged = staged

        super().__init__(action="addExternalImage")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringAddExternalImageAction":
        from ._schemas.product_tailoring import (
            ProductTailoringAddExternalImageActionSchema,
        )

        return ProductTailoringAddExternalImageActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import (
            ProductTailoringAddExternalImageActionSchema,
        )

        return ProductTailoringAddExternalImageActionSchema().dump(self)


class ProductTailoringAddVariantAction(ProductTailoringUpdateAction):
    """Either `id` or `sku` is required to reference a [ProductVariant](ctp:api:type:ProductVariant) that exists.
    Produces the [ProductVariantTailoringAdded](ctp:api:type:ProductVariantTailoringAddedMessage) Message.

    """

    #: The `id` of the tailored ProductVariant to update.
    id: typing.Optional[int]
    #: The `sku` of the tailored ProductVariant to update.
    sku: typing.Optional[str]
    #: Images for the Product Variant Tailoring.
    images: typing.Optional[typing.List["Image"]]
    #: Media assets for the Product Variant Tailoring.
    assets: typing.Optional[typing.List["AssetDraft"]]
    #: If `true` the new Product Variant Tailoring is only staged. If `false` the new Product Variant Tailoring is both current and staged.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        images: typing.Optional[typing.List["Image"]] = None,
        assets: typing.Optional[typing.List["AssetDraft"]] = None,
        staged: typing.Optional[bool] = None
    ):
        self.id = id
        self.sku = sku
        self.images = images
        self.assets = assets
        self.staged = staged

        super().__init__(action="addVariant")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringAddVariantAction":
        from ._schemas.product_tailoring import ProductTailoringAddVariantActionSchema

        return ProductTailoringAddVariantActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringAddVariantActionSchema

        return ProductTailoringAddVariantActionSchema().dump(self)


class ProductTailoringChangeAssetNameAction(ProductTailoringUpdateAction):
    """Either `variantId` or `sku` is required to reference a [ProductVariant](ctp:api:type:ProductVariant) that exists.
    The Asset to update must be specified using either `assetId` or `assetKey`.

    """

    #: The `id` of the tailored ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the tailored ProductVariant to update.
    sku: typing.Optional[str]
    #: If `true`, only the staged Asset is updated. If `false`, both the current and staged Asset is updated.
    staged: typing.Optional[bool]
    #: The `id` of the Asset to update.
    asset_id: typing.Optional[str]
    #: The `key` of the Asset to update.
    asset_key: typing.Optional[str]
    #: New value to set. Must not be empty.
    name: "LocalizedString"

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None,
        asset_id: typing.Optional[str] = None,
        asset_key: typing.Optional[str] = None,
        name: "LocalizedString"
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged
        self.asset_id = asset_id
        self.asset_key = asset_key
        self.name = name

        super().__init__(action="changeAssetName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringChangeAssetNameAction":
        from ._schemas.product_tailoring import (
            ProductTailoringChangeAssetNameActionSchema,
        )

        return ProductTailoringChangeAssetNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import (
            ProductTailoringChangeAssetNameActionSchema,
        )

        return ProductTailoringChangeAssetNameActionSchema().dump(self)


class ProductTailoringChangeAssetOrderAction(ProductTailoringUpdateAction):
    """Either `variantId` or `sku` is required to reference a [ProductVariant](ctp:api:type:ProductVariant) that exists."""

    #: The `id` of the tailored ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the tailored ProductVariant to update.
    sku: typing.Optional[str]
    #: If `true`, only the staged `assets` is updated. If `false`, both the current and staged `assets` are updated.
    staged: typing.Optional[bool]
    #: All existing Asset `id`s of the ProductTailoringVariant in the desired new order.
    asset_order: typing.List["str"]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None,
        asset_order: typing.List["str"]
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged
        self.asset_order = asset_order

        super().__init__(action="changeAssetOrder")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringChangeAssetOrderAction":
        from ._schemas.product_tailoring import (
            ProductTailoringChangeAssetOrderActionSchema,
        )

        return ProductTailoringChangeAssetOrderActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import (
            ProductTailoringChangeAssetOrderActionSchema,
        )

        return ProductTailoringChangeAssetOrderActionSchema().dump(self)


class ProductTailoringMoveImageToPositionAction(ProductTailoringUpdateAction):
    """Either `variantId` or `sku` is required to reference a [ProductVariant](ctp:api:type:ProductVariant) that exists."""

    #: The `id` of the tailored ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the tailored ProductVariant to update.
    sku: typing.Optional[str]
    #: The URL of the image to update.
    image_url: str
    #: Position in `images` where the image should be moved. Must be between `0` and the total number of images minus `1`.
    position: int
    #: If `true`, only the staged `images` is updated. If `false`, both the current and staged `images` is updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        image_url: str,
        position: int,
        staged: typing.Optional[bool] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.image_url = image_url
        self.position = position
        self.staged = staged

        super().__init__(action="moveImageToPosition")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringMoveImageToPositionAction":
        from ._schemas.product_tailoring import (
            ProductTailoringMoveImageToPositionActionSchema,
        )

        return ProductTailoringMoveImageToPositionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import (
            ProductTailoringMoveImageToPositionActionSchema,
        )

        return ProductTailoringMoveImageToPositionActionSchema().dump(self)


class ProductTailoringPublishAction(ProductTailoringUpdateAction):
    """Publishes the `staged` data of the ProductTailoring to `current`. Sets `hasStagedChanges` to `false`.
    Generates the [ProductTailoringPublished](ctp:api:type:ProductTailoringPublishedMessage) Message.

    """

    def __init__(self):

        super().__init__(action="publish")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringPublishAction":
        from ._schemas.product_tailoring import ProductTailoringPublishActionSchema

        return ProductTailoringPublishActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringPublishActionSchema

        return ProductTailoringPublishActionSchema().dump(self)


class ProductTailoringRemoveAssetAction(ProductTailoringUpdateAction):
    """Either `variantId` or `sku` is required to reference a [ProductVariant](ctp:api:type:ProductVariant) that exists.
    The Asset to remove must be specified using either `assetId` or `assetKey`.

    """

    #: The `id` of the tailored ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the tailored ProductVariant to update.
    sku: typing.Optional[str]
    #: If `true`, only the staged Asset is removed. If `false`, both the current and staged Asset is removed.
    staged: typing.Optional[bool]
    #: The `id` of the Asset to remove.
    asset_id: typing.Optional[str]
    #: The `key` of the Asset to remove.
    asset_key: typing.Optional[str]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None,
        asset_id: typing.Optional[str] = None,
        asset_key: typing.Optional[str] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged
        self.asset_id = asset_id
        self.asset_key = asset_key

        super().__init__(action="removeAsset")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringRemoveAssetAction":
        from ._schemas.product_tailoring import ProductTailoringRemoveAssetActionSchema

        return ProductTailoringRemoveAssetActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringRemoveAssetActionSchema

        return ProductTailoringRemoveAssetActionSchema().dump(self)


class ProductTailoringRemoveImageAction(ProductTailoringUpdateAction):
    """Either `variantId` or `sku` is required to reference a [ProductVariant](ctp:api:type:ProductVariant) that exists."""

    #: The `id` of the tailored ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the tailored ProductVariant to update.
    sku: typing.Optional[str]
    #: The URL of the image to remove.
    image_url: str
    #: If `true`, only the staged image is removed. If `false`, both the current and staged image is removed.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        image_url: str,
        staged: typing.Optional[bool] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.image_url = image_url
        self.staged = staged

        super().__init__(action="removeImage")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringRemoveImageAction":
        from ._schemas.product_tailoring import ProductTailoringRemoveImageActionSchema

        return ProductTailoringRemoveImageActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringRemoveImageActionSchema

        return ProductTailoringRemoveImageActionSchema().dump(self)


class ProductTailoringRemoveVariantAction(ProductTailoringUpdateAction):
    """Either `id` or `sku` is required.
    Produces the [ProductVariantTailoringDeleted](ctp:api:type:ProductVariantTailoringRemovedMessage) Message.

    """

    #: The `id` of the ProductVariant to remove from the Tailoring.
    id: typing.Optional[int]
    #: The `sku` of the ProductVariant to remove from the Tailoring.
    sku: typing.Optional[str]
    #: If `true`, only the staged Product Variant Tailoring is removed. If `false`, both the current and staged Product Variant Tailoring is removed.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None
    ):
        self.id = id
        self.sku = sku
        self.staged = staged

        super().__init__(action="removeVariant")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringRemoveVariantAction":
        from ._schemas.product_tailoring import (
            ProductTailoringRemoveVariantActionSchema,
        )

        return ProductTailoringRemoveVariantActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import (
            ProductTailoringRemoveVariantActionSchema,
        )

        return ProductTailoringRemoveVariantActionSchema().dump(self)


class ProductTailoringSetAssetCustomFieldAction(ProductTailoringUpdateAction):
    """Either `variantId` or `sku` is required to reference a [ProductVariant](ctp:api:type:ProductVariant) that exists.
    The [Asset](ctp:api:type:Asset) to update must be specified using either `assetId` or `assetKey`.

    """

    #: The `id` of the tailored ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the tailored ProductVariant to update.
    sku: typing.Optional[str]
    #: If `true`, only the staged Asset is updated. If `false`, both the current and staged Asset is updated.
    staged: typing.Optional[bool]
    #: The `id` of the Asset to update.
    asset_id: typing.Optional[str]
    #: The `key` of the Asset to update.
    asset_key: typing.Optional[str]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None,
        asset_id: typing.Optional[str] = None,
        asset_key: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged
        self.asset_id = asset_id
        self.asset_key = asset_key
        self.name = name
        self.value = value

        super().__init__(action="setAssetCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetAssetCustomFieldAction":
        from ._schemas.product_tailoring import (
            ProductTailoringSetAssetCustomFieldActionSchema,
        )

        return ProductTailoringSetAssetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import (
            ProductTailoringSetAssetCustomFieldActionSchema,
        )

        return ProductTailoringSetAssetCustomFieldActionSchema().dump(self)


class ProductTailoringSetAssetCustomTypeAction(ProductTailoringUpdateAction):
    """Either `variantId` or `sku` is required to reference a [ProductVariant](ctp:api:type:ProductVariant) that exists.
    The [Asset](ctp:api:type:Asset) to update must be specified using either `assetId` or `assetKey`.

    """

    #: The `id` of the tailored ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the tailored ProductVariant to update.
    sku: typing.Optional[str]
    #: If `true`, only the staged Asset is updated. If `false`, both the current and staged Asset is updated.
    staged: typing.Optional[bool]
    #: The `id` of the Asset to update.
    asset_id: typing.Optional[str]
    #: The `key` of the Asset to update.
    asset_key: typing.Optional[str]
    #: Defines the [Type](ctp:api:type:Type) that extends the Asset with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Asset.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Asset.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None,
        asset_id: typing.Optional[str] = None,
        asset_key: typing.Optional[str] = None,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged
        self.asset_id = asset_id
        self.asset_key = asset_key
        self.type = type
        self.fields = fields

        super().__init__(action="setAssetCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetAssetCustomTypeAction":
        from ._schemas.product_tailoring import (
            ProductTailoringSetAssetCustomTypeActionSchema,
        )

        return ProductTailoringSetAssetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import (
            ProductTailoringSetAssetCustomTypeActionSchema,
        )

        return ProductTailoringSetAssetCustomTypeActionSchema().dump(self)


class ProductTailoringSetAssetDescriptionAction(ProductTailoringUpdateAction):
    """Either `variantId` or `sku` is required to reference a [ProductVariant](ctp:api:type:ProductVariant) that exists.
    The [Asset](ctp:api:type:Asset) to update must be specified using either `assetId` or `assetKey`.

    """

    #: The `id` of the tailored ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the tailored ProductVariant to update.
    sku: typing.Optional[str]
    #: If `true`, only the staged Asset is updated. If `false`, both the current and staged Asset is updated.
    staged: typing.Optional[bool]
    #: The `id` of the Asset to update.
    asset_id: typing.Optional[str]
    #: The `key` of the Asset to update.
    asset_key: typing.Optional[str]
    #: Value to set. If empty, any existing value will be removed.
    description: typing.Optional["LocalizedString"]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None,
        asset_id: typing.Optional[str] = None,
        asset_key: typing.Optional[str] = None,
        description: typing.Optional["LocalizedString"] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged
        self.asset_id = asset_id
        self.asset_key = asset_key
        self.description = description

        super().__init__(action="setAssetDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetAssetDescriptionAction":
        from ._schemas.product_tailoring import (
            ProductTailoringSetAssetDescriptionActionSchema,
        )

        return ProductTailoringSetAssetDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import (
            ProductTailoringSetAssetDescriptionActionSchema,
        )

        return ProductTailoringSetAssetDescriptionActionSchema().dump(self)


class ProductTailoringSetAssetKeyAction(ProductTailoringUpdateAction):
    """Either `variantId` or `sku` is required to reference a [ProductVariant](ctp:api:type:ProductVariant) that exists."""

    #: The `id` of the tailored ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the tailored ProductVariant to update.
    sku: typing.Optional[str]
    #: If `true`, only the staged Asset is updated. If `false`, both the current and staged Asset is updated.
    staged: typing.Optional[bool]
    #: The `id` of the Asset to update.
    asset_id: str
    #: Value to set. If empty, any existing value will be removed.
    asset_key: typing.Optional[str]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None,
        asset_id: str,
        asset_key: typing.Optional[str] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged
        self.asset_id = asset_id
        self.asset_key = asset_key

        super().__init__(action="setAssetKey")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetAssetKeyAction":
        from ._schemas.product_tailoring import ProductTailoringSetAssetKeyActionSchema

        return ProductTailoringSetAssetKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringSetAssetKeyActionSchema

        return ProductTailoringSetAssetKeyActionSchema().dump(self)


class ProductTailoringSetAssetSourcesAction(ProductTailoringUpdateAction):
    """Either `variantId` or `sku` is required to reference a [ProductVariant](ctp:api:type:ProductVariant) that exists.
    The [Asset](ctp:api:type:Asset) to update must be specified using either `assetId` or `assetKey`.

    """

    #: The `id` of the tailored ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the tailored ProductVariant to update.
    sku: typing.Optional[str]
    #: If `true`, only the staged Asset is updated. If `false` both the current and staged Asset is updated.
    staged: typing.Optional[bool]
    #: The `id` of the Asset to update.
    asset_id: typing.Optional[str]
    #: The `key` of the Asset to update.
    asset_key: typing.Optional[str]
    #: Value to set.
    sources: typing.List["AssetSource"]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None,
        asset_id: typing.Optional[str] = None,
        asset_key: typing.Optional[str] = None,
        sources: typing.List["AssetSource"]
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged
        self.asset_id = asset_id
        self.asset_key = asset_key
        self.sources = sources

        super().__init__(action="setAssetSources")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetAssetSourcesAction":
        from ._schemas.product_tailoring import (
            ProductTailoringSetAssetSourcesActionSchema,
        )

        return ProductTailoringSetAssetSourcesActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import (
            ProductTailoringSetAssetSourcesActionSchema,
        )

        return ProductTailoringSetAssetSourcesActionSchema().dump(self)


class ProductTailoringSetAssetTagsAction(ProductTailoringUpdateAction):
    """Either `variantId` or `sku` is required to reference a [ProductVariant](ctp:api:type:ProductVariant) that exists.
    The Asset to update must be specified using either `assetId` or `assetKey`.

    """

    #: The `id` of the tailored ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the tailored ProductVariant to update.
    sku: typing.Optional[str]
    #: If `true`, only the staged Asset is updated. If `false`, both the current and staged Asset is updated.
    staged: typing.Optional[bool]
    #: The `id` of the Asset to update.
    asset_id: typing.Optional[str]
    #: The `key` of the Asset to update.
    asset_key: typing.Optional[str]
    #: Keywords for categorizing and organizing Assets.
    tags: typing.Optional[typing.List["str"]]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None,
        asset_id: typing.Optional[str] = None,
        asset_key: typing.Optional[str] = None,
        tags: typing.Optional[typing.List["str"]] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged
        self.asset_id = asset_id
        self.asset_key = asset_key
        self.tags = tags

        super().__init__(action="setAssetTags")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetAssetTagsAction":
        from ._schemas.product_tailoring import ProductTailoringSetAssetTagsActionSchema

        return ProductTailoringSetAssetTagsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringSetAssetTagsActionSchema

        return ProductTailoringSetAssetTagsActionSchema().dump(self)


class ProductTailoringSetDescriptionAction(ProductTailoringUpdateAction):
    """Generates the [ProductTailoringDescriptionSet](ctp:api:type:ProductTailoringDescriptionSetMessage) Message."""

    #: Value to set. If empty, any existing value will be removed.
    description: typing.Optional["LocalizedString"]
    #: If `true`, only the staged `description` is updated. If `false`, both the current and staged `description` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        description: typing.Optional["LocalizedString"] = None,
        staged: typing.Optional[bool] = None
    ):
        self.description = description
        self.staged = staged

        super().__init__(action="setDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetDescriptionAction":
        from ._schemas.product_tailoring import (
            ProductTailoringSetDescriptionActionSchema,
        )

        return ProductTailoringSetDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import (
            ProductTailoringSetDescriptionActionSchema,
        )

        return ProductTailoringSetDescriptionActionSchema().dump(self)


class ProductTailoringSetExternalImagesAction(ProductTailoringUpdateAction):
    """Either `variantId` or `sku` is required to reference a [ProductVariant](ctp:api:type:ProductVariant) that exists. Produces the [ProductTailoringImagesSet](/projects/messages#product-tailoring-images-set) Message."""

    #: The `id` of the tailored ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the tailored ProductVariant to update.
    sku: typing.Optional[str]
    #: Value to set to `images`.
    images: typing.List["Image"]
    #: If `true`, only the staged `images` is updated. If `false`, both the current and staged `images` is updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        images: typing.List["Image"],
        staged: typing.Optional[bool] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.images = images
        self.staged = staged

        super().__init__(action="setImages")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetExternalImagesAction":
        from ._schemas.product_tailoring import (
            ProductTailoringSetExternalImagesActionSchema,
        )

        return ProductTailoringSetExternalImagesActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import (
            ProductTailoringSetExternalImagesActionSchema,
        )

        return ProductTailoringSetExternalImagesActionSchema().dump(self)


class ProductTailoringSetImageLabelAction(ProductTailoringUpdateAction):
    """Either `variantId` or `sku` is required to reference a [ProductVariant](ctp:api:type:ProductVariant) that exists."""

    #: The `sku` of the tailored ProductVariant to update.
    sku: typing.Optional[str]
    #: The `id` of the tailored ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The URL of the image to set the label.
    image_url: str
    #: Value to set. If empty, any existing value will be removed.
    label: typing.Optional[str]
    #: If `true`, only the staged image is updated. If `false`, both the current and staged image is updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        sku: typing.Optional[str] = None,
        variant_id: typing.Optional[int] = None,
        image_url: str,
        label: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None
    ):
        self.sku = sku
        self.variant_id = variant_id
        self.image_url = image_url
        self.label = label
        self.staged = staged

        super().__init__(action="setImageLabel")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetImageLabelAction":
        from ._schemas.product_tailoring import (
            ProductTailoringSetImageLabelActionSchema,
        )

        return ProductTailoringSetImageLabelActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import (
            ProductTailoringSetImageLabelActionSchema,
        )

        return ProductTailoringSetImageLabelActionSchema().dump(self)


class ProductTailoringSetMetaAttributesAction(ProductTailoringUpdateAction):
    """Updates all meta attributes at the same time."""

    #: Value to set. If empty, any existing value will be removed.
    meta_title: typing.Optional["LocalizedString"]
    #: Value to set. If empty, any existing value will be removed.
    meta_description: typing.Optional["LocalizedString"]
    #: Value to set. If empty, any existing value will be removed.
    meta_keywords: typing.Optional["LocalizedString"]
    #: If `true`, only the staged attributes are updated. If `false`, both the current and staged attributes are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        meta_title: typing.Optional["LocalizedString"] = None,
        meta_description: typing.Optional["LocalizedString"] = None,
        meta_keywords: typing.Optional["LocalizedString"] = None,
        staged: typing.Optional[bool] = None
    ):
        self.meta_title = meta_title
        self.meta_description = meta_description
        self.meta_keywords = meta_keywords
        self.staged = staged

        super().__init__(action="setMetaAttributes")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetMetaAttributesAction":
        from ._schemas.product_tailoring import (
            ProductTailoringSetMetaAttributesActionSchema,
        )

        return ProductTailoringSetMetaAttributesActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import (
            ProductTailoringSetMetaAttributesActionSchema,
        )

        return ProductTailoringSetMetaAttributesActionSchema().dump(self)


class ProductTailoringSetMetaDescriptionAction(ProductTailoringUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    meta_description: typing.Optional["LocalizedString"]
    #: If `true`, only the staged `metaDescription` is updated. If `false`, both the current and staged `metaDescription` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        meta_description: typing.Optional["LocalizedString"] = None,
        staged: typing.Optional[bool] = None
    ):
        self.meta_description = meta_description
        self.staged = staged

        super().__init__(action="setMetaDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetMetaDescriptionAction":
        from ._schemas.product_tailoring import (
            ProductTailoringSetMetaDescriptionActionSchema,
        )

        return ProductTailoringSetMetaDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import (
            ProductTailoringSetMetaDescriptionActionSchema,
        )

        return ProductTailoringSetMetaDescriptionActionSchema().dump(self)


class ProductTailoringSetMetaKeywordsAction(ProductTailoringUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    meta_keywords: typing.Optional["LocalizedString"]
    #: If `true`, only the staged `metaKeywords` is updated. If `false`, both the current and staged `metaKeywords` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        meta_keywords: typing.Optional["LocalizedString"] = None,
        staged: typing.Optional[bool] = None
    ):
        self.meta_keywords = meta_keywords
        self.staged = staged

        super().__init__(action="setMetaKeywords")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetMetaKeywordsAction":
        from ._schemas.product_tailoring import (
            ProductTailoringSetMetaKeywordsActionSchema,
        )

        return ProductTailoringSetMetaKeywordsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import (
            ProductTailoringSetMetaKeywordsActionSchema,
        )

        return ProductTailoringSetMetaKeywordsActionSchema().dump(self)


class ProductTailoringSetMetaTitleAction(ProductTailoringUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    meta_title: typing.Optional["LocalizedString"]
    #: If `true`, only the staged `metaTitle` is updated. If `false`, both the current and staged `metaTitle` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        meta_title: typing.Optional["LocalizedString"] = None,
        staged: typing.Optional[bool] = None
    ):
        self.meta_title = meta_title
        self.staged = staged

        super().__init__(action="setMetaTitle")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetMetaTitleAction":
        from ._schemas.product_tailoring import ProductTailoringSetMetaTitleActionSchema

        return ProductTailoringSetMetaTitleActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringSetMetaTitleActionSchema

        return ProductTailoringSetMetaTitleActionSchema().dump(self)


class ProductTailoringSetNameAction(ProductTailoringUpdateAction):
    """Generates the [ProductTailoringNameSet](ctp:api:type:ProductTailoringNameSetMessage) Message."""

    #: Value to set. If empty, any existing value will be removed.
    name: typing.Optional["LocalizedString"]
    #: If `true`, only the staged `name` is updated. If `false`, both the current and staged `name` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        name: typing.Optional["LocalizedString"] = None,
        staged: typing.Optional[bool] = None
    ):
        self.name = name
        self.staged = staged

        super().__init__(action="setName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetNameAction":
        from ._schemas.product_tailoring import ProductTailoringSetNameActionSchema

        return ProductTailoringSetNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringSetNameActionSchema

        return ProductTailoringSetNameActionSchema().dump(self)


class ProductTailoringSetSlugAction(ProductTailoringUpdateAction):
    """Generates the [ProductTailoringSlugSet](ctp:api:type:ProductTailoringSlugSetMessage) Message."""

    #: Value to set. If empty, any existing value will be removed.
    slug: typing.Optional["LocalizedString"]
    #: If `true`, only the staged `slug` is updated. If `false`, both the current and staged `slug` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        slug: typing.Optional["LocalizedString"] = None,
        staged: typing.Optional[bool] = None
    ):
        self.slug = slug
        self.staged = staged

        super().__init__(action="setSlug")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetSlugAction":
        from ._schemas.product_tailoring import ProductTailoringSetSlugActionSchema

        return ProductTailoringSetSlugActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringSetSlugActionSchema

        return ProductTailoringSetSlugActionSchema().dump(self)


class ProductTailoringUnpublishAction(ProductTailoringUpdateAction):
    """Unpublishes the `current` data of the ProductTailoring. Sets the `published` field to `false`.
    Generates the [ProductTailoringUnpublished](ctp:api:type:ProductTailoringUnpublishedMessage) Message.

    """

    def __init__(self):

        super().__init__(action="unpublish")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringUnpublishAction":
        from ._schemas.product_tailoring import ProductTailoringUnpublishActionSchema

        return ProductTailoringUnpublishActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringUnpublishActionSchema

        return ProductTailoringUnpublishActionSchema().dump(self)
