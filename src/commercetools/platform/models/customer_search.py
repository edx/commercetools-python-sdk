# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .project import CustomerIndexingStatus

if typing.TYPE_CHECKING:
    from .project import CustomerIndexingStatus
    from .search import SearchQuery, SearchSorting

__all__ = [
    "CustomerIndexingProgress",
    "CustomerPagedSearchResponse",
    "CustomerSearchIndexingStatusResponse",
    "CustomerSearchRequest",
    "CustomerSearchResult",
]


class CustomerIndexingProgress(_BaseType):
    #: The number of Customers successfully indexed.
    indexed: int
    #: The number of Customers that failed to be indexed.
    failed: int
    #: The estimated total number of Customers to be indexed.
    estimated_total: int

    def __init__(self, *, indexed: int, failed: int, estimated_total: int):
        self.indexed = indexed
        self.failed = failed
        self.estimated_total = estimated_total

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerIndexingProgress":
        from ._schemas.customer_search import CustomerIndexingProgressSchema

        return CustomerIndexingProgressSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer_search import CustomerIndexingProgressSchema

        return CustomerIndexingProgressSchema().dump(self)


class CustomerPagedSearchResponse(_BaseType):
    #: Total number of results matching the query.
    total: int
    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: Search result containing the Customers matching the search query.
    results: typing.List["CustomerSearchResult"]

    def __init__(
        self,
        *,
        total: int,
        limit: int,
        offset: int,
        results: typing.List["CustomerSearchResult"]
    ):
        self.total = total
        self.limit = limit
        self.offset = offset
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerPagedSearchResponse":
        from ._schemas.customer_search import CustomerPagedSearchResponseSchema

        return CustomerPagedSearchResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer_search import CustomerPagedSearchResponseSchema

        return CustomerPagedSearchResponseSchema().dump(self)


class CustomerSearchIndexingStatusResponse(_BaseType):
    #: Current status of indexing the Customer Search.
    status: "CustomerIndexingStatus"
    #: Progress of indexing. Only available when indexing is in progress.
    states: typing.Optional["CustomerIndexingProgress"]
    #: Date and time (UTC) when the last indexing started.
    started_at: typing.Optional[datetime.datetime]
    #: Time when the status was last modified.
    last_modified_at: typing.Optional[datetime.datetime]
    #: Indicates how many times the system tried to start indexing after failed attempts. The counter is set to null after an indexing finished successfully.
    retry_count: typing.Optional[int]

    def __init__(
        self,
        *,
        status: "CustomerIndexingStatus",
        states: typing.Optional["CustomerIndexingProgress"] = None,
        started_at: typing.Optional[datetime.datetime] = None,
        last_modified_at: typing.Optional[datetime.datetime] = None,
        retry_count: typing.Optional[int] = None
    ):
        self.status = status
        self.states = states
        self.started_at = started_at
        self.last_modified_at = last_modified_at
        self.retry_count = retry_count

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerSearchIndexingStatusResponse":
        from ._schemas.customer_search import CustomerSearchIndexingStatusResponseSchema

        return CustomerSearchIndexingStatusResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer_search import CustomerSearchIndexingStatusResponseSchema

        return CustomerSearchIndexingStatusResponseSchema().dump(self)


class CustomerSearchRequest(_BaseType):
    #: The Customer search query.
    query: typing.Optional["SearchQuery"]
    #: Controls how results to your query are sorted. If not provided, the results are sorted by relevance in descending order.
    sort: typing.Optional[typing.List["SearchSorting"]]
    #: The maximum number of search results to be returned.
    limit: typing.Optional[int]
    #: The number of search results to be skipped in the response for pagination.
    offset: typing.Optional[int]

    def __init__(
        self,
        *,
        query: typing.Optional["SearchQuery"] = None,
        sort: typing.Optional[typing.List["SearchSorting"]] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None
    ):
        self.query = query
        self.sort = sort
        self.limit = limit
        self.offset = offset

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomerSearchRequest":
        from ._schemas.customer_search import CustomerSearchRequestSchema

        return CustomerSearchRequestSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer_search import CustomerSearchRequestSchema

        return CustomerSearchRequestSchema().dump(self)


class CustomerSearchResult(_BaseType):
    #: `id` of the [Customer](ctp:api:type:Customer) matching the search query.
    id: str
    #: How closely this customer matches the search query.
    relevance: float

    def __init__(self, *, id: str, relevance: float):
        self.id = id
        self.relevance = relevance

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomerSearchResult":
        from ._schemas.customer_search import CustomerSearchResultSchema

        return CustomerSearchResultSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer_search import CustomerSearchResultSchema

        return CustomerSearchResultSchema().dump(self)
