# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .common import IntegrationType, Region

if typing.TYPE_CHECKING:
    from . import CertificationInfo, ConnectorReport, Creator, Repository
    from .common import ConnectorConfigurationApplication, IntegrationType, Region

__all__ = [
    "Connector",
    "ConnectorAddCertificationCommentAction",
    "ConnectorAddPrivateProjectAction",
    "ConnectorDraft",
    "ConnectorPublishAction",
    "ConnectorRemovePrivateProjectAction",
    "ConnectorSearchPagedQueryResponse",
    "ConnectorSetCreatorCompanyAction",
    "ConnectorSetCreatorEmailAction",
    "ConnectorSetCreatorLogoAction",
    "ConnectorSetCreatorNameAction",
    "ConnectorSetCreatorNoOfContributorsAction",
    "ConnectorSetCreatorSupportUrlAction",
    "ConnectorSetCreatorTitleAction",
    "ConnectorSetDescriptionAction",
    "ConnectorSetDocumentationUrlAction",
    "ConnectorSetIntegrationTypesAction",
    "ConnectorSetNameAction",
    "ConnectorSetRepositoryAction",
    "ConnectorSetSupportedRegionsAction",
    "ConnectorStaged",
    "ConnectorStagedPagedQueryResponse",
    "ConnectorUnlistAction",
    "ConnectorUpdate",
    "ConnectorUpdateAction",
    "ConnectorUpdatePreviewableAction",
]


class Connector(_BaseType):
    #: Unique identifier of the Connector.
    id: str
    #: User-defined unique identifier of the Connector.
    key: typing.Optional[str]
    #: Current version of the Connector.
    version: int
    #: Name of the Connector.
    name: str
    #: Description of the Connector.
    description: typing.Optional[str]
    #: Integration types of the Connector. Can be used to filter search and query results.
    integration_types: typing.List["IntegrationType"]
    #: Owner of the Connector.
    creator: "Creator"
    #: GitHub repository details of the Connector.
    repository: "Repository"
    #: Configurations needed by Connectors for hosting. Loaded as environment variables in the workload.
    configurations: typing.Optional[typing.List["ConnectorConfigurationApplication"]]
    #: If `true`, only Composable Commerce Projects specified in `privateProjects` can access the Connector.
    private: bool
    #: If not empty, Connectors can only be deployed in these Regions. If empty, Connectors can be deployed in any [supported Region](hosts-and-authorization#hosts).
    supported_regions: typing.List["Region"]
    #: If `true`, the Connector is certified.
    certified: bool
    #: URL to the documentation of the Connector.
    documentation_url: typing.Optional[str]

    def __init__(
        self,
        *,
        id: str,
        key: typing.Optional[str] = None,
        version: int,
        name: str,
        description: typing.Optional[str] = None,
        integration_types: typing.List["IntegrationType"],
        creator: "Creator",
        repository: "Repository",
        configurations: typing.Optional[
            typing.List["ConnectorConfigurationApplication"]
        ] = None,
        private: bool,
        supported_regions: typing.List["Region"],
        certified: bool,
        documentation_url: typing.Optional[str] = None
    ):
        self.id = id
        self.key = key
        self.version = version
        self.name = name
        self.description = description
        self.integration_types = integration_types
        self.creator = creator
        self.repository = repository
        self.configurations = configurations
        self.private = private
        self.supported_regions = supported_regions
        self.certified = certified
        self.documentation_url = documentation_url

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Connector":
        from ._schemas.connector import ConnectorSchema

        return ConnectorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorSchema

        return ConnectorSchema().dump(self)


class ConnectorDraft(_BaseType):
    #: User-defined unique identifier of the Connector.
    key: typing.Optional[str]
    #: Name of the Connector.
    name: str
    #: Description of the Connector.
    description: typing.Optional[str]
    #: Integration types of the Connector. Can be used to filter search and query results.
    integration_types: typing.Optional[typing.List["IntegrationType"]]
    #: Owner of the Connector.
    creator: "Creator"
    #: GitHub repository details of the Connector.
    repository: "Repository"
    #: If provided, Connectors can only be deployed in these Regions. If not provided, Connectors can be deployed in any [supported Region](hosts-and-authorization#hosts).
    supported_regions: typing.Optional[typing.List["Region"]]
    #: Composable Commerce Projects that can access the Connector. If empty, only the creator can access this Connector.
    private_projects: typing.Optional[typing.List["str"]]
    #: URL to the documentation of the Connector.
    documentation_url: typing.Optional[str]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        name: str,
        description: typing.Optional[str] = None,
        integration_types: typing.Optional[typing.List["IntegrationType"]] = None,
        creator: "Creator",
        repository: "Repository",
        supported_regions: typing.Optional[typing.List["Region"]] = None,
        private_projects: typing.Optional[typing.List["str"]] = None,
        documentation_url: typing.Optional[str] = None
    ):
        self.key = key
        self.name = name
        self.description = description
        self.integration_types = integration_types
        self.creator = creator
        self.repository = repository
        self.supported_regions = supported_regions
        self.private_projects = private_projects
        self.documentation_url = documentation_url

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ConnectorDraft":
        from ._schemas.connector import ConnectorDraftSchema

        return ConnectorDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorDraftSchema

        return ConnectorDraftSchema().dump(self)


class ConnectorStaged(_BaseType):
    #: Unique identifier of the Connector.
    id: str
    #: User-defined unique identifier of the Connector.
    key: typing.Optional[str]
    #: Current version of the Connector.
    version: int
    #: Name of the Connector.
    name: str
    #: Description of the Connector.
    description: str
    #: Integration types of the Connector. Can be used to filter search and query results.
    integration_types: typing.List["IntegrationType"]
    #: Owner of the Connector.
    creator: "Creator"
    #: GitHub repository details of the Connector.
    repository: "Repository"
    #: Configurations needed by Connectors for hosting. Loaded as environment variables in the workload.
    configurations: typing.List["ConnectorConfigurationApplication"]
    #: If `true`, only Composable Commerce Projects specified in `privateProjects` can access the Connector.
    private: bool
    #: If `private` is true, only these Composable Commerce Projects can access the Connector.
    private_projects: typing.List["str"]
    #: If not empty, Connectors can only be deployed in these Regions. If empty, Connectors can be deployed in any [supported Region](hosts-and-authorization#hosts).
    supported_regions: typing.List["Region"]
    #: Comments made during the certification process.
    certification_info: typing.Optional["CertificationInfo"]
    #: Current status of the Connector.
    status: str
    #: The publishing request report of the Connector.
    publishing_report: typing.Optional["ConnectorReport"]
    #: If `true`, the Connector is published and ready for use.
    already_listed: bool
    #: If `true`, the ConnectorStaged data is different from the production [Connector](ctp:connect:type:Connector) data.
    has_changes: bool
    #: The previewable status of the ConnectorStaged.
    is_previewable: str
    #: The previewable request report.
    previewable_report: typing.Optional["ConnectorReport"]
    #: URL to the documentation of the Connector.
    documentation_url: typing.Optional[str]

    def __init__(
        self,
        *,
        id: str,
        key: typing.Optional[str] = None,
        version: int,
        name: str,
        description: str,
        integration_types: typing.List["IntegrationType"],
        creator: "Creator",
        repository: "Repository",
        configurations: typing.List["ConnectorConfigurationApplication"],
        private: bool,
        private_projects: typing.List["str"],
        supported_regions: typing.List["Region"],
        certification_info: typing.Optional["CertificationInfo"] = None,
        status: str,
        publishing_report: typing.Optional["ConnectorReport"] = None,
        already_listed: bool,
        has_changes: bool,
        is_previewable: str,
        previewable_report: typing.Optional["ConnectorReport"] = None,
        documentation_url: typing.Optional[str] = None
    ):
        self.id = id
        self.key = key
        self.version = version
        self.name = name
        self.description = description
        self.integration_types = integration_types
        self.creator = creator
        self.repository = repository
        self.configurations = configurations
        self.private = private
        self.private_projects = private_projects
        self.supported_regions = supported_regions
        self.certification_info = certification_info
        self.status = status
        self.publishing_report = publishing_report
        self.already_listed = already_listed
        self.has_changes = has_changes
        self.is_previewable = is_previewable
        self.previewable_report = previewable_report
        self.documentation_url = documentation_url

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ConnectorStaged":
        from ._schemas.connector import ConnectorStagedSchema

        return ConnectorStagedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorStagedSchema

        return ConnectorStagedSchema().dump(self)


class ConnectorStagedPagedQueryResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) with results containing an array of [ConnectorStaged](ctp:connect:type:ConnectorStaged)."""

    #: The maximum number of the ConnectorStaged returned.
    limit: int
    #: The offset of the ConnectorStaged returned.
    offset: int
    #: The number of ConnectorStaged returned.
    count: int
    #: The total number of ConnectorStaged matching the query.
    total: int
    #: ConnectorStaged matching the query.
    results: typing.List["ConnectorStaged"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: int,
        results: typing.List["ConnectorStaged"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorStagedPagedQueryResponse":
        from ._schemas.connector import ConnectorStagedPagedQueryResponseSchema

        return ConnectorStagedPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorStagedPagedQueryResponseSchema

        return ConnectorStagedPagedQueryResponseSchema().dump(self)


class ConnectorSearchPagedQueryResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) with results containing an array of [Connector](ctp:connect:type:Connector)."""

    #: The maximum number of Connectors returned.
    limit: int
    #: The offset of the Connectors returned.
    offset: int
    #: The number of Connectors returned.
    count: int
    #: The total number of Connectors matching the query.
    total: int
    #: Connectors matching the query.
    results: typing.List["Connector"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: int,
        results: typing.List["Connector"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorSearchPagedQueryResponse":
        from ._schemas.connector import ConnectorSearchPagedQueryResponseSchema

        return ConnectorSearchPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorSearchPagedQueryResponseSchema

        return ConnectorSearchPagedQueryResponseSchema().dump(self)


class ConnectorUpdate(_BaseType):
    #: Expected version of the Connector on which the changes apply.
    version: int
    #: Update actions to be performed on the Connector.
    actions: typing.List["ConnectorUpdateAction"]

    def __init__(self, *, version: int, actions: typing.List["ConnectorUpdateAction"]):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ConnectorUpdate":
        from ._schemas.connector import ConnectorUpdateSchema

        return ConnectorUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorUpdateSchema

        return ConnectorUpdateSchema().dump(self)


class ConnectorUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ConnectorUpdateAction":
        if data["action"] == "setCreatorCompany":
            from ._schemas.connector import ConnectorSetCreatorCompanyActionSchema

            return ConnectorSetCreatorCompanyActionSchema().load(data)
        if data["action"] == "setCreatorEmail":
            from ._schemas.connector import ConnectorSetCreatorEmailActionSchema

            return ConnectorSetCreatorEmailActionSchema().load(data)
        if data["action"] == "setCreatorName":
            from ._schemas.connector import ConnectorSetCreatorNameActionSchema

            return ConnectorSetCreatorNameActionSchema().load(data)
        if data["action"] == "setCreatorTitle":
            from ._schemas.connector import ConnectorSetCreatorTitleActionSchema

            return ConnectorSetCreatorTitleActionSchema().load(data)
        if data["action"] == "setDescription":
            from ._schemas.connector import ConnectorSetDescriptionActionSchema

            return ConnectorSetDescriptionActionSchema().load(data)
        if data["action"] == "setCreatorSupportUrl":
            from ._schemas.connector import ConnectorSetCreatorSupportUrlActionSchema

            return ConnectorSetCreatorSupportUrlActionSchema().load(data)
        if data["action"] == "setName":
            from ._schemas.connector import ConnectorSetNameActionSchema

            return ConnectorSetNameActionSchema().load(data)
        if data["action"] == "setCreatorLogo":
            from ._schemas.connector import ConnectorSetCreatorLogoActionSchema

            return ConnectorSetCreatorLogoActionSchema().load(data)
        if data["action"] == "setCreatorNoOfContributors":
            from ._schemas.connector import (
                ConnectorSetCreatorNoOfContributorsActionSchema,
            )

            return ConnectorSetCreatorNoOfContributorsActionSchema().load(data)
        if data["action"] == "addPrivateProject":
            from ._schemas.connector import ConnectorAddPrivateProjectActionSchema

            return ConnectorAddPrivateProjectActionSchema().load(data)
        if data["action"] == "removePrivateProject":
            from ._schemas.connector import ConnectorRemovePrivateProjectActionSchema

            return ConnectorRemovePrivateProjectActionSchema().load(data)
        if data["action"] == "setRepository":
            from ._schemas.connector import ConnectorSetRepositoryActionSchema

            return ConnectorSetRepositoryActionSchema().load(data)
        if data["action"] == "setSupportedRegions":
            from ._schemas.connector import ConnectorSetSupportedRegionsActionSchema

            return ConnectorSetSupportedRegionsActionSchema().load(data)
        if data["action"] == "setDocumentationUrl":
            from ._schemas.connector import ConnectorSetDocumentationUrlActionSchema

            return ConnectorSetDocumentationUrlActionSchema().load(data)
        if data["action"] == "setIntegrationTypes":
            from ._schemas.connector import ConnectorSetIntegrationTypesActionSchema

            return ConnectorSetIntegrationTypesActionSchema().load(data)
        if data["action"] == "unlist":
            from ._schemas.connector import ConnectorUnlistActionSchema

            return ConnectorUnlistActionSchema().load(data)
        if data["action"] == "addCertificationComment":
            from ._schemas.connector import ConnectorAddCertificationCommentActionSchema

            return ConnectorAddCertificationCommentActionSchema().load(data)
        if data["action"] == "updatePreviewable":
            from ._schemas.connector import ConnectorUpdatePreviewableActionSchema

            return ConnectorUpdatePreviewableActionSchema().load(data)
        if data["action"] == "publish":
            from ._schemas.connector import ConnectorPublishActionSchema

            return ConnectorPublishActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorUpdateActionSchema

        return ConnectorUpdateActionSchema().dump(self)


class ConnectorSetCreatorCompanyAction(ConnectorUpdateAction):
    """Updates the company of the creator."""

    #: Value to set.
    creator_company: str

    def __init__(self, *, creator_company: str):
        self.creator_company = creator_company

        super().__init__(action="setCreatorCompany")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorSetCreatorCompanyAction":
        from ._schemas.connector import ConnectorSetCreatorCompanyActionSchema

        return ConnectorSetCreatorCompanyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorSetCreatorCompanyActionSchema

        return ConnectorSetCreatorCompanyActionSchema().dump(self)


class ConnectorSetCreatorEmailAction(ConnectorUpdateAction):
    """Updates the email address of the creator."""

    #: Value to set.
    creator_email: str

    def __init__(self, *, creator_email: str):
        self.creator_email = creator_email

        super().__init__(action="setCreatorEmail")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorSetCreatorEmailAction":
        from ._schemas.connector import ConnectorSetCreatorEmailActionSchema

        return ConnectorSetCreatorEmailActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorSetCreatorEmailActionSchema

        return ConnectorSetCreatorEmailActionSchema().dump(self)


class ConnectorSetCreatorNameAction(ConnectorUpdateAction):
    """Updates the name of the creator."""

    #: Value to set.
    creator_name: str

    def __init__(self, *, creator_name: str):
        self.creator_name = creator_name

        super().__init__(action="setCreatorName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorSetCreatorNameAction":
        from ._schemas.connector import ConnectorSetCreatorNameActionSchema

        return ConnectorSetCreatorNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorSetCreatorNameActionSchema

        return ConnectorSetCreatorNameActionSchema().dump(self)


class ConnectorSetCreatorTitleAction(ConnectorUpdateAction):
    """Updates the title of the creator."""

    #: Value to set.
    creator_title: str

    def __init__(self, *, creator_title: str):
        self.creator_title = creator_title

        super().__init__(action="setCreatorTitle")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorSetCreatorTitleAction":
        from ._schemas.connector import ConnectorSetCreatorTitleActionSchema

        return ConnectorSetCreatorTitleActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorSetCreatorTitleActionSchema

        return ConnectorSetCreatorTitleActionSchema().dump(self)


class ConnectorSetDescriptionAction(ConnectorUpdateAction):
    """Updates the description of the Connector."""

    #: Value to set.
    description: str

    def __init__(self, *, description: str):
        self.description = description

        super().__init__(action="setDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorSetDescriptionAction":
        from ._schemas.connector import ConnectorSetDescriptionActionSchema

        return ConnectorSetDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorSetDescriptionActionSchema

        return ConnectorSetDescriptionActionSchema().dump(self)


class ConnectorSetCreatorSupportUrlAction(ConnectorUpdateAction):
    """Updates the support URL of the creator."""

    #: Value to set.
    creator_support_url: str

    def __init__(self, *, creator_support_url: str):
        self.creator_support_url = creator_support_url

        super().__init__(action="setCreatorSupportUrl")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorSetCreatorSupportUrlAction":
        from ._schemas.connector import ConnectorSetCreatorSupportUrlActionSchema

        return ConnectorSetCreatorSupportUrlActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorSetCreatorSupportUrlActionSchema

        return ConnectorSetCreatorSupportUrlActionSchema().dump(self)


class ConnectorSetNameAction(ConnectorUpdateAction):
    """Updates the name of the Connector."""

    #: Value to set.
    name: str

    def __init__(self, *, name: str):
        self.name = name

        super().__init__(action="setName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorSetNameAction":
        from ._schemas.connector import ConnectorSetNameActionSchema

        return ConnectorSetNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorSetNameActionSchema

        return ConnectorSetNameActionSchema().dump(self)


class ConnectorSetCreatorLogoAction(ConnectorUpdateAction):
    """Updates the logo of the creator."""

    #: Value to set.
    logo_url: str

    def __init__(self, *, logo_url: str):
        self.logo_url = logo_url

        super().__init__(action="setCreatorLogo")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorSetCreatorLogoAction":
        from ._schemas.connector import ConnectorSetCreatorLogoActionSchema

        return ConnectorSetCreatorLogoActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorSetCreatorLogoActionSchema

        return ConnectorSetCreatorLogoActionSchema().dump(self)


class ConnectorSetCreatorNoOfContributorsAction(ConnectorUpdateAction):
    """Updates the number of contributors of the creator."""

    #: Value to set.
    creator_no_of_contributors: int

    def __init__(self, *, creator_no_of_contributors: int):
        self.creator_no_of_contributors = creator_no_of_contributors

        super().__init__(action="setCreatorNoOfContributors")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorSetCreatorNoOfContributorsAction":
        from ._schemas.connector import ConnectorSetCreatorNoOfContributorsActionSchema

        return ConnectorSetCreatorNoOfContributorsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorSetCreatorNoOfContributorsActionSchema

        return ConnectorSetCreatorNoOfContributorsActionSchema().dump(self)


class ConnectorAddPrivateProjectAction(ConnectorUpdateAction):
    """Allow a Composable Commerce Project to access a private Connector.

    Attempting to add a `privateProject` to a non-private ConnectorStaged returns the [ConnectorStagedNotPrivate](ctp:connect:type:ConnectorStagedNotPrivateError) error.

    """

    #: The Composable Commerce Project to add to `privateProjects`.
    private_project: str

    def __init__(self, *, private_project: str):
        self.private_project = private_project

        super().__init__(action="addPrivateProject")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorAddPrivateProjectAction":
        from ._schemas.connector import ConnectorAddPrivateProjectActionSchema

        return ConnectorAddPrivateProjectActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorAddPrivateProjectActionSchema

        return ConnectorAddPrivateProjectActionSchema().dump(self)


class ConnectorRemovePrivateProjectAction(ConnectorUpdateAction):
    """Remove a Composable Commerce Project's access to a private Connector.

    Attempting to remove a `privateProject` from a non-private ConnectorStaged returns the [ConnectorStagedNotPrivate](ctp:connect:type:ConnectorStagedNotPrivateError) error.

    """

    #: The Composable Commerce Project to remove from `privateProjects`.
    private_project: str

    def __init__(self, *, private_project: str):
        self.private_project = private_project

        super().__init__(action="removePrivateProject")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorRemovePrivateProjectAction":
        from ._schemas.connector import ConnectorRemovePrivateProjectActionSchema

        return ConnectorRemovePrivateProjectActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorRemovePrivateProjectActionSchema

        return ConnectorRemovePrivateProjectActionSchema().dump(self)


class ConnectorSetRepositoryAction(ConnectorUpdateAction):
    """Updates the GitHub repository details of the Connector."""

    #: New HTTPS or SSH GitHub URL to assign to the Connector.
    url: str
    #: New Git tag to assign to the Connector.
    tag: str

    def __init__(self, *, url: str, tag: str):
        self.url = url
        self.tag = tag

        super().__init__(action="setRepository")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorSetRepositoryAction":
        from ._schemas.connector import ConnectorSetRepositoryActionSchema

        return ConnectorSetRepositoryActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorSetRepositoryActionSchema

        return ConnectorSetRepositoryActionSchema().dump(self)


class ConnectorSetSupportedRegionsAction(ConnectorUpdateAction):
    """Updates the regions that the Connector can be deployed in."""

    #: New value to set.
    regions: typing.List["Region"]

    def __init__(self, *, regions: typing.List["Region"]):
        self.regions = regions

        super().__init__(action="setSupportedRegions")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorSetSupportedRegionsAction":
        from ._schemas.connector import ConnectorSetSupportedRegionsActionSchema

        return ConnectorSetSupportedRegionsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorSetSupportedRegionsActionSchema

        return ConnectorSetSupportedRegionsActionSchema().dump(self)


class ConnectorSetDocumentationUrlAction(ConnectorUpdateAction):
    """Updates the documentation URL of the Connector."""

    #: Value to set.
    documentation_url: str

    def __init__(self, *, documentation_url: str):
        self.documentation_url = documentation_url

        super().__init__(action="setDocumentationUrl")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorSetDocumentationUrlAction":
        from ._schemas.connector import ConnectorSetDocumentationUrlActionSchema

        return ConnectorSetDocumentationUrlActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorSetDocumentationUrlActionSchema

        return ConnectorSetDocumentationUrlActionSchema().dump(self)


class ConnectorSetIntegrationTypesAction(ConnectorUpdateAction):
    """Updates the integration types of the Connector."""

    #: New value to set.
    integration_types: typing.List["IntegrationType"]

    def __init__(self, *, integration_types: typing.List["IntegrationType"]):
        self.integration_types = integration_types

        super().__init__(action="setIntegrationTypes")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorSetIntegrationTypesAction":
        from ._schemas.connector import ConnectorSetIntegrationTypesActionSchema

        return ConnectorSetIntegrationTypesActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorSetIntegrationTypesActionSchema

        return ConnectorSetIntegrationTypesActionSchema().dump(self)


class ConnectorUnlistAction(ConnectorUpdateAction):
    """Removes a certified and listed Connector from search results and listings. This update action does not affect deployed instances of the Connector."""

    def __init__(self):

        super().__init__(action="unlist")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ConnectorUnlistAction":
        from ._schemas.connector import ConnectorUnlistActionSchema

        return ConnectorUnlistActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorUnlistActionSchema

        return ConnectorUnlistActionSchema().dump(self)


class ConnectorAddCertificationCommentAction(ConnectorUpdateAction):
    """Add a comment during the certification process of the Connector."""

    #: Comment to add.
    comment: str

    def __init__(self, *, comment: str):
        self.comment = comment

        super().__init__(action="addCertificationComment")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorAddCertificationCommentAction":
        from ._schemas.connector import ConnectorAddCertificationCommentActionSchema

        return ConnectorAddCertificationCommentActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorAddCertificationCommentActionSchema

        return ConnectorAddCertificationCommentActionSchema().dump(self)


class ConnectorUpdatePreviewableAction(ConnectorUpdateAction):
    """Requests the previewable status of a ConnectorStaged. A previewable ConnectorStaged can be used in a Deployment for testing and preview purposes.

    After using this update action, the status of `isPreviewable` will change to `pending`. Following validation, the status of `isPreviewable` will change to `true` if the previewable status is granted, or `false` if it is rejected.
    In the case of a `false` status, contact the [Connect support team](https://support.commercetools.com/) regarding any issues raised during the validation process.

    Requesting the previewable status for a ConnectorStaged that is currently being reviewed returns the [ConnectorStagedPreviewRequestUnderProcess](ctp:connect:type:ConnectorStagedPreviewRequestUnderProcessError) error.

    """

    def __init__(self):

        super().__init__(action="updatePreviewable")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorUpdatePreviewableAction":
        from ._schemas.connector import ConnectorUpdatePreviewableActionSchema

        return ConnectorUpdatePreviewableActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorUpdatePreviewableActionSchema

        return ConnectorUpdatePreviewableActionSchema().dump(self)


class ConnectorPublishAction(ConnectorUpdateAction):
    """Starts the Connector publishing process. You will be unable to update the Connector until the process completes.

    `certification` should only be `true` if you want to make the Connector publicly available.

    """

    #: - Set to `false` to make the Connector private and skip the [certification process](/certification). The published Connector will only be deployable on Projects listed in `ConnectorStaged.privateProjects`.
    #: - Set to `true` to make the Connector public. This will submit the ConnectorStaged to the [certification process](/certification). After completing the certification process, the Connector will become publicly available.
    certification: bool

    def __init__(self, *, certification: bool):
        self.certification = certification

        super().__init__(action="publish")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorPublishAction":
        from ._schemas.connector import ConnectorPublishActionSchema

        return ConnectorPublishActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.connector import ConnectorPublishActionSchema

        return ConnectorPublishActionSchema().dump(self)
