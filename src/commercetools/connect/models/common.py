# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType

__all__ = [
    "ApplicationDeployment",
    "Artifact",
    "CertificationInfo",
    "CertificationInfoComment",
    "ConfigurationKeySecured",
    "ConfigurationKeyStandard",
    "ConfigurationValue",
    "ConnectorConfigurationApplication",
    "ConnectorReference",
    "ConnectorReport",
    "ConnectorReportEntry",
    "ConnectorReportEntryType",
    "ConnectorStatus",
    "Creator",
    "DeploymentConfigurationApplication",
    "DeploymentConnector",
    "DeploymentCreator",
    "DeploymentDetails",
    "DeploymentDetailsBuild",
    "DeploymentLogSeverity",
    "DeploymentReport",
    "DeploymentReportEntry",
    "DeploymentReportEntryType",
    "DeploymentStatus",
    "DeploymentType",
    "IntegrationType",
    "IsPreviewable",
    "Region",
    "Repository",
]


class Artifact(_BaseType):
    """A connector internal build artifact (ex: docker image)."""

    application_name: str
    artifact_path: str

    def __init__(self, *, application_name: str, artifact_path: str):
        self.application_name = application_name
        self.artifact_path = artifact_path

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Artifact":
        from ._schemas.common import ArtifactSchema

        return ArtifactSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ArtifactSchema

        return ArtifactSchema().dump(self)


class CertificationInfo(_BaseType):
    #: Comments made during the certification process.
    comments: typing.List["CertificationInfoComment"]

    def __init__(self, *, comments: typing.List["CertificationInfoComment"]):
        self.comments = comments

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CertificationInfo":
        from ._schemas.common import CertificationInfoSchema

        return CertificationInfoSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import CertificationInfoSchema

        return CertificationInfoSchema().dump(self)


class CertificationInfoComment(_BaseType):
    """Contains metadata and body text of a comment made during the certification process."""

    #: The commercetools Composable Commerce Project key associated with the person making the comment.
    user_id: str
    #: Date and time (UTC) the comment was added.
    datetime: datetime.datetime
    #: The body text of the comment.
    comment: str

    def __init__(self, *, user_id: str, datetime: datetime.datetime, comment: str):
        self.user_id = user_id
        self.datetime = datetime
        self.comment = comment

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CertificationInfoComment":
        from ._schemas.common import CertificationInfoCommentSchema

        return CertificationInfoCommentSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import CertificationInfoCommentSchema

        return CertificationInfoCommentSchema().dump(self)


class ConfigurationKeyStandard(_BaseType):
    """The name, description, and default value of a standard environment variable."""

    #: Name of the environment variable.
    key: str
    #: Description of the environment variable.
    description: str
    #: Default value of the environment variable.
    default: typing.Optional[str]
    #: Indicates if the environment variable is required.
    required: typing.Optional[bool]

    def __init__(
        self,
        *,
        key: str,
        description: str,
        default: typing.Optional[str] = None,
        required: typing.Optional[bool] = None
    ):
        self.key = key
        self.description = description
        self.default = default
        self.required = required

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConfigurationKeyStandard":
        from ._schemas.common import ConfigurationKeyStandardSchema

        return ConfigurationKeyStandardSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ConfigurationKeyStandardSchema

        return ConfigurationKeyStandardSchema().dump(self)


class ConfigurationKeySecured(_BaseType):
    """The name and description of a secret environment variable."""

    #: Name of the environment variable.
    key: str
    #: Description of the environment variable.
    description: str
    #: Indicates if the environment variable is required.
    required: typing.Optional[bool]

    def __init__(
        self, *, key: str, description: str, required: typing.Optional[bool] = None
    ):
        self.key = key
        self.description = description
        self.required = required

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConfigurationKeySecured":
        from ._schemas.common import ConfigurationKeySecuredSchema

        return ConfigurationKeySecuredSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ConfigurationKeySecuredSchema

        return ConfigurationKeySecuredSchema().dump(self)


class ConfigurationValue(_BaseType):
    #: Name of the environment variable.
    key: str
    #: Value of the environment variable.
    value: str

    def __init__(self, *, key: str, value: str):
        self.key = key
        self.value = value

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ConfigurationValue":
        from ._schemas.common import ConfigurationValueSchema

        return ConfigurationValueSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ConfigurationValueSchema

        return ConfigurationValueSchema().dump(self)


class ConnectorConfigurationApplication(_BaseType):
    """The configuration of a Connect application. These values are automatically obtained from the connect.yaml file in the GitHub repository."""

    #: Name of the Connect application.
    application_name: str
    #: The Connect application type.
    application_type: str
    #: Contains the name, description, and default values of standard environment variables.
    standard_configuration: typing.List["ConfigurationKeyStandard"]
    #: Contains the name and description of secret environment variables.
    secured_configuration: typing.List["ConfigurationKeySecured"]

    def __init__(
        self,
        *,
        application_name: str,
        application_type: str,
        standard_configuration: typing.List["ConfigurationKeyStandard"],
        secured_configuration: typing.List["ConfigurationKeySecured"]
    ):
        self.application_name = application_name
        self.application_type = application_type
        self.standard_configuration = standard_configuration
        self.secured_configuration = secured_configuration

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorConfigurationApplication":
        from ._schemas.common import ConnectorConfigurationApplicationSchema

        return ConnectorConfigurationApplicationSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ConnectorConfigurationApplicationSchema

        return ConnectorConfigurationApplicationSchema().dump(self)


class DeploymentConfigurationApplication(_BaseType):
    """Describes the configuration set of a given application."""

    #: Name of the application. Should match the value of `name` within the connect.yaml file of the Connect application.
    application_name: str
    #: Contains values of keys that are saved in plain text. Can be accessed after being set.
    standard_configuration: typing.List["ConfigurationValue"]
    #: Contains values of secret keys. Cannot be accessed after being set.
    secured_configuration: typing.List["ConfigurationValue"]

    def __init__(
        self,
        *,
        application_name: str,
        standard_configuration: typing.List["ConfigurationValue"],
        secured_configuration: typing.List["ConfigurationValue"]
    ):
        self.application_name = application_name
        self.standard_configuration = standard_configuration
        self.secured_configuration = secured_configuration

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DeploymentConfigurationApplication":
        from ._schemas.common import DeploymentConfigurationApplicationSchema

        return DeploymentConfigurationApplicationSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import DeploymentConfigurationApplicationSchema

        return DeploymentConfigurationApplicationSchema().dump(self)


class ApplicationDeployment(_BaseType):
    """Describes an application deployment of the Connector."""

    #: Unique identifier of the application deployment.
    id: str
    #: Name of the application. Should match the value of `name` within the connect.yaml file of the Connector.
    application_name: str
    #: Contains values of keys that are saved in plain text. Can be accessed after being set.
    standard_configuration: typing.List["ConfigurationValue"]
    #: Contains values of secret keys. After being set, these values are encrypted and cannot be accessed.
    secured_configuration: typing.List["ConfigurationValue"]
    #: URL generated after deployment of service applications.
    url: typing.Optional[str]
    #: Pub/Sub Topic generated after deployment of event applications.
    topic: typing.Optional[str]
    #: Cron schedule for job applications.
    schedule: typing.Optional[str]

    def __init__(
        self,
        *,
        id: str,
        application_name: str,
        standard_configuration: typing.List["ConfigurationValue"],
        secured_configuration: typing.List["ConfigurationValue"],
        url: typing.Optional[str] = None,
        topic: typing.Optional[str] = None,
        schedule: typing.Optional[str] = None
    ):
        self.id = id
        self.application_name = application_name
        self.standard_configuration = standard_configuration
        self.secured_configuration = secured_configuration
        self.url = url
        self.topic = topic
        self.schedule = schedule

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ApplicationDeployment":
        from ._schemas.common import ApplicationDeploymentSchema

        return ApplicationDeploymentSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ApplicationDeploymentSchema

        return ApplicationDeploymentSchema().dump(self)


class ConnectorReportEntryType(enum.Enum):
    """The type of message being reported."""

    INFORMATION = "Information"
    WARNING = "Warning"
    ERROR = "Error"


class ConnectorReportEntry(_BaseType):
    """Describes an information, error, or warning notice."""

    #: The report entry type.
    type: "ConnectorReportEntryType"
    #: The title of the report entry.
    title: str
    #: The message related to the report entry.
    message: typing.Optional[str]
    #: When the report entry was created.
    created_at: datetime.datetime

    def __init__(
        self,
        *,
        type: "ConnectorReportEntryType",
        title: str,
        message: typing.Optional[str] = None,
        created_at: datetime.datetime
    ):
        self.type = type
        self.title = title
        self.message = message
        self.created_at = created_at

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ConnectorReportEntry":
        from ._schemas.common import ConnectorReportEntrySchema

        return ConnectorReportEntrySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ConnectorReportEntrySchema

        return ConnectorReportEntrySchema().dump(self)


class ConnectorReport(_BaseType):
    """Contains report entries for publish/preview requests."""

    #: Contains information, error, and warning notices.
    entries: typing.List["ConnectorReportEntry"]

    def __init__(self, *, entries: typing.List["ConnectorReportEntry"]):
        self.entries = entries

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ConnectorReport":
        from ._schemas.common import ConnectorReportSchema

        return ConnectorReportSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ConnectorReportSchema

        return ConnectorReportSchema().dump(self)


class ConnectorStatus(enum.Enum):
    """Indicates the current status of the ConnectorStaged."""

    DRAFT = "Draft"
    PROCESSING = "Processing"
    READY_FOR_CERTIFICATION = "ReadyForCertification"
    IN_CERTIFICATION = "InCertification"
    PUBLISHED = "Published"
    FAILED = "Failed"


class ConnectorReference(_BaseType):
    """Reference to a [Connector](ctp:connect:type:Connector) or [ConnectorStaged](ctp:connect:type:ConnectorStaged). Either `id` or `key` is required."""

    #: Unique identifier of the referenced Connector.
    id: typing.Optional[str]
    #: User-defined unique identifier of the referenced Connector.
    key: typing.Optional[str]
    #: If `true`, a previewable [ConnectorStaged](ctp:connect:type:ConnectorStaged) must be referenced in `id` or `key` instead of the published Connector. The `isPreviewable` field of the [ConnectorStaged](ctp:connect:type:ConnectorStaged) must be `true` to reference a previewable ConnectorStaged.
    staged: typing.Optional[bool]
    #: Version of the referenced Connector.
    version: typing.Optional[int]

    def __init__(
        self,
        *,
        id: typing.Optional[str] = None,
        key: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None,
        version: typing.Optional[int] = None
    ):
        self.id = id
        self.key = key
        self.staged = staged
        self.version = version

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ConnectorReference":
        from ._schemas.common import ConnectorReferenceSchema

        return ConnectorReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ConnectorReferenceSchema

        return ConnectorReferenceSchema().dump(self)


class Creator(_BaseType):
    """Details of the individual or organization who developed the Connector."""

    #: Name of the person who owns the Connector.
    name: typing.Optional[str]
    #: Title of the person who owns the Connector.
    title: typing.Optional[str]
    #: Contact email address of the creator.
    email: str
    #: Name of the company that owns the Connector.
    company: typing.Optional[str]
    #: URL to a logo image used to represent the creator.
    logo_url: typing.Optional[str]
    #: Number of contributors currently working for the company.
    no_of_contributors: typing.Optional[int]
    #: URL to the support website of the Connector.
    support_url: typing.Optional[str]

    def __init__(
        self,
        *,
        name: typing.Optional[str] = None,
        title: typing.Optional[str] = None,
        email: str,
        company: typing.Optional[str] = None,
        logo_url: typing.Optional[str] = None,
        no_of_contributors: typing.Optional[int] = None,
        support_url: typing.Optional[str] = None
    ):
        self.name = name
        self.title = title
        self.email = email
        self.company = company
        self.logo_url = logo_url
        self.no_of_contributors = no_of_contributors
        self.support_url = support_url

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Creator":
        from ._schemas.common import CreatorSchema

        return CreatorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import CreatorSchema

        return CreatorSchema().dump(self)


class DeploymentConnector(_BaseType):
    """The details of the deployed [Connector](ctp:connect:type:Connector)."""

    #: `id` of the Connector.
    id: str
    #: User-defined unique identifier of the Connector.
    key: typing.Optional[str]
    #: Version of the Connector.
    version: int
    #: Name of the Connector.
    name: str
    #: Description of the Connector.
    description: typing.Optional[str]
    #: Connector integration type list.
    integration_types: typing.List["IntegrationType"]
    #: Owner of the Connector.
    creator: "DeploymentCreator"
    #: Details of the GitHub repository that contains the Connect applications.
    repository: "Repository"
    #: If `true`, the Connector is certified.
    certified: bool

    def __init__(
        self,
        *,
        id: str,
        key: typing.Optional[str] = None,
        version: int,
        name: str,
        description: typing.Optional[str] = None,
        integration_types: typing.List["IntegrationType"],
        creator: "DeploymentCreator",
        repository: "Repository",
        certified: bool
    ):
        self.id = id
        self.key = key
        self.version = version
        self.name = name
        self.description = description
        self.integration_types = integration_types
        self.creator = creator
        self.repository = repository
        self.certified = certified

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DeploymentConnector":
        from ._schemas.common import DeploymentConnectorSchema

        return DeploymentConnectorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import DeploymentConnectorSchema

        return DeploymentConnectorSchema().dump(self)


class DeploymentCreator(_BaseType):
    """The details of the deployed [DeploymentConnector](ctp:connect:type:DeploymentConnector) creator."""

    #: Name of the person who owns the Connector.
    name: typing.Optional[str]
    #: Title of the person who owns the Connector.
    title: typing.Optional[str]
    #: Contact email address of the creator.
    email: str
    #: Name of the company that owns the Connector.
    company: typing.Optional[str]
    #: Number of contributors currently working for the company.
    no_of_contributors: typing.Optional[int]

    def __init__(
        self,
        *,
        name: typing.Optional[str] = None,
        title: typing.Optional[str] = None,
        email: str,
        company: typing.Optional[str] = None,
        no_of_contributors: typing.Optional[int] = None
    ):
        self.name = name
        self.title = title
        self.email = email
        self.company = company
        self.no_of_contributors = no_of_contributors

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DeploymentCreator":
        from ._schemas.common import DeploymentCreatorSchema

        return DeploymentCreatorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import DeploymentCreatorSchema

        return DeploymentCreatorSchema().dump(self)


class DeploymentReportEntryType(enum.Enum):
    """The type of message being reported."""

    INFORMATION = "Information"
    WARNING = "Warning"
    ERROR = "Error"


class DeploymentReportEntry(_BaseType):
    """Describes an information, error, or warning in the deployment report."""

    #: The report entry type.
    type: "DeploymentReportEntryType"
    #: The title of the report entry.
    title: str
    #: The message related to the report entry.
    message: typing.Optional[str]
    #: The name of the Connect application related to the entry.
    application: typing.Optional[str]
    #: When the report entry was created.
    created_at: datetime.datetime

    def __init__(
        self,
        *,
        type: "DeploymentReportEntryType",
        title: str,
        message: typing.Optional[str] = None,
        application: typing.Optional[str] = None,
        created_at: datetime.datetime
    ):
        self.type = type
        self.title = title
        self.message = message
        self.application = application
        self.created_at = created_at

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DeploymentReportEntry":
        from ._schemas.common import DeploymentReportEntrySchema

        return DeploymentReportEntrySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import DeploymentReportEntrySchema

        return DeploymentReportEntrySchema().dump(self)


class DeploymentReport(_BaseType):
    """Describes a report of the Connector deployment process."""

    #: Contains informations, errors and warnings about the Connector deployment.
    entries: typing.List["DeploymentReportEntry"]

    def __init__(self, *, entries: typing.List["DeploymentReportEntry"]):
        self.entries = entries

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DeploymentReport":
        from ._schemas.common import DeploymentReportSchema

        return DeploymentReportSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import DeploymentReportSchema

        return DeploymentReportSchema().dump(self)


class DeploymentDetailsBuild(_BaseType):
    #: The build execution id of the deployed application.
    id: str
    #: The build report of the deployed Connector.
    report: typing.Optional["DeploymentReport"]

    def __init__(self, *, id: str, report: typing.Optional["DeploymentReport"] = None):
        self.id = id
        self.report = report

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DeploymentDetailsBuild":
        from ._schemas.common import DeploymentDetailsBuildSchema

        return DeploymentDetailsBuildSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import DeploymentDetailsBuildSchema

        return DeploymentDetailsBuildSchema().dump(self)


class DeploymentDetails(_BaseType):
    """Additional details about the deployed Connector."""

    #: The build details of deployed applications.
    build: "DeploymentDetailsBuild"

    def __init__(self, *, build: "DeploymentDetailsBuild"):
        self.build = build

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DeploymentDetails":
        from ._schemas.common import DeploymentDetailsSchema

        return DeploymentDetailsSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import DeploymentDetailsSchema

        return DeploymentDetailsSchema().dump(self)


class DeploymentStatus(enum.Enum):
    """Indicates the current status of the Deployment."""

    DRAFT = "Draft"
    QUEUED = "Queued"
    DEPLOYING = "Deploying"
    DEPLOYED = "Deployed"
    FAILED = "Failed"
    UNDEPLOYING = "Undeploying"
    UNDEPLOY_FAILED = "UndeployFailed"


class DeploymentLogSeverity(enum.Enum):
    """The severity of the log message."""

    DEFAULT = "DEFAULT"
    DEBUG = "DEBUG"
    INFO = "INFO"
    NOTICE = "NOTICE"
    WARNING = "WARNING"
    ERROR = "ERROR"
    CRITICAL = "CRITICAL"
    ALERT = "ALERT"
    EMERGENCY = "EMERGENCY"


class Region(enum.Enum):
    """The Region of a commercetools Composable Commerce Project or Deployment. For more information, see [Hosts](/hosts-and-authorization#hosts)."""

    EUROPE_WEST1.GCP = "europe-west1.gcp"
    US_CENTRAL1.GCP = "us-central1.gcp"
    AUSTRALIA_SOUTHEAST1.GCP = "australia-southeast1.gcp"


class IntegrationType(enum.Enum):
    """Integration type of the Connector."""

    TAX = "tax"
    MARKETPLACE = "marketplace"
    OMS = "oms"
    PSP = "psp"
    PIM = "pim"
    PROMOTION = "promotion"
    SEARCH = "search"
    ERP = "erp"
    CRM = "crm"
    EMAIL = "email"
    ANALYTICS = "analytics"
    SHIPPING = "shipping"
    OTHER = "other"


class DeploymentType(enum.Enum):
    """Deployment type of the Connector."""

    PREVIEW = "preview"
    PRODUCTION = "production"


class Repository(_BaseType):
    """Details of the GitHub repository that contains the Connect applications."""

    #: HTTPS or SSH GitHub URL of the GitHub repository. Private repositories must use an SSH URL.
    url: str
    #: Git tag of the release to use.
    tag: str

    def __init__(self, *, url: str, tag: str):
        self.url = url
        self.tag = tag

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Repository":
        from ._schemas.common import RepositorySchema

        return RepositorySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import RepositorySchema

        return RepositorySchema().dump(self)


class IsPreviewable(enum.Enum):
    """The previewable status of the ConnectorStaged."""

    TRUE = "true"
    FALSE = "false"
    PENDING = "pending"
    NONE = "none"
