# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType

__all__ = [
    "AuthenticationError",
    "AuthorizationError",
    "BadGatewayError",
    "ConcurrentModificationError",
    "ConnectorAlreadyCertifiedError",
    "ConnectorReferenceNotFoundError",
    "ConnectorSpecificationFileNotFoundError",
    "ConnectorSpecificationFileNotValidError",
    "ConnectorStagedInCertificationError",
    "ConnectorStagedNotPreviewableError",
    "ConnectorStagedNotPrivateError",
    "ConnectorStagedPreviewRequestUnderProcessError",
    "DeploymentApplicationDoNotBelongError",
    "DeploymentApplicationRequiredError",
    "DeploymentConnectorUpdateFailureError",
    "DeploymentInvalidStatusTransitionError",
    "DeploymentMustIncludeApplicationError",
    "DeploymentUnknownApplicationConfigurationError",
    "DeploymentUnknownApplicationConfigurationKeyError",
    "DeploymentUnsupportedRegionError",
    "DuplicateFieldError",
    "ErrorObject",
    "ErrorResponse",
    "FieldValueNotFoundError",
    "GeneralError",
    "GitRepositoryNotReachableError",
    "InvalidJsonInputError",
    "InvalidPathParamError",
    "InvalidQueryParamError",
    "ResourceNotFoundError",
]


class ErrorObject(_BaseType):
    """Represents a single error. Multiple errors may be included in an [ErrorResponse](ctp:connect:type:ErrorResponse)."""

    #: Error identifier.
    code: str
    #: Plain text description of the cause of the error.
    message: str

    def __init__(self, *, code: str, message: str, **kwargs):
        self.code = code
        self.message = message
        self.__dict__.update(kwargs)

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ErrorObject":
        if data["code"] == "AuthenticationError":
            from ._schemas.error import AuthenticationErrorSchema

            return AuthenticationErrorSchema().load(data)
        if data["code"] == "AuthorizationError":
            from ._schemas.error import AuthorizationErrorSchema

            return AuthorizationErrorSchema().load(data)
        if data["code"] == "BadGateway":
            from ._schemas.error import BadGatewayErrorSchema

            return BadGatewayErrorSchema().load(data)
        if data["code"] == "ConcurrentModification":
            from ._schemas.error import ConcurrentModificationErrorSchema

            return ConcurrentModificationErrorSchema().load(data)
        if data["code"] == "DuplicateField":
            from ._schemas.error import DuplicateFieldErrorSchema

            return DuplicateFieldErrorSchema().load(data)
        if data["code"] == "FieldValueNotFound":
            from ._schemas.error import FieldValueNotFoundErrorSchema

            return FieldValueNotFoundErrorSchema().load(data)
        if data["code"] == "General":
            from ._schemas.error import GeneralErrorSchema

            return GeneralErrorSchema().load(data)
        if data["code"] == "InvalidJsonInput":
            from ._schemas.error import InvalidJsonInputErrorSchema

            return InvalidJsonInputErrorSchema().load(data)
        if data["code"] == "InvalidPathParam":
            from ._schemas.error import InvalidPathParamErrorSchema

            return InvalidPathParamErrorSchema().load(data)
        if data["code"] == "InvalidQueryParam":
            from ._schemas.error import InvalidQueryParamErrorSchema

            return InvalidQueryParamErrorSchema().load(data)
        if data["code"] == "ResourceNotFound":
            from ._schemas.error import ResourceNotFoundErrorSchema

            return ResourceNotFoundErrorSchema().load(data)
        if data["code"] == "ConnectorAlreadyCertified":
            from ._schemas.error import ConnectorAlreadyCertifiedErrorSchema

            return ConnectorAlreadyCertifiedErrorSchema().load(data)
        if data["code"] == "ConnectorStagedInCertification":
            from ._schemas.error import ConnectorStagedInCertificationErrorSchema

            return ConnectorStagedInCertificationErrorSchema().load(data)
        if data["code"] == "ConnectorStagedNotPreviewable":
            from ._schemas.error import ConnectorStagedNotPreviewableErrorSchema

            return ConnectorStagedNotPreviewableErrorSchema().load(data)
        if data["code"] == "ConnectorStagedNotPrivate":
            from ._schemas.error import ConnectorStagedNotPrivateErrorSchema

            return ConnectorStagedNotPrivateErrorSchema().load(data)
        if data["code"] == "ConnectorStagedPreviewRequestUnderProcess":
            from ._schemas.error import (
                ConnectorStagedPreviewRequestUnderProcessErrorSchema,
            )

            return ConnectorStagedPreviewRequestUnderProcessErrorSchema().load(data)
        if data["code"] == "GitRepositoryNotReachable":
            from ._schemas.error import GitRepositoryNotReachableErrorSchema

            return GitRepositoryNotReachableErrorSchema().load(data)
        if data["code"] == "ConnectorSpecificationFileNotFound":
            from ._schemas.error import ConnectorSpecificationFileNotFoundErrorSchema

            return ConnectorSpecificationFileNotFoundErrorSchema().load(data)
        if data["code"] == "ConnectorSpecificationFileNotValid":
            from ._schemas.error import ConnectorSpecificationFileNotValidErrorSchema

            return ConnectorSpecificationFileNotValidErrorSchema().load(data)
        if data["code"] == "ConnectorReferenceNotFound":
            from ._schemas.error import ConnectorReferenceNotFoundErrorSchema

            return ConnectorReferenceNotFoundErrorSchema().load(data)
        if data["code"] == "DeploymentConnectorUpdateFailure":
            from ._schemas.error import DeploymentConnectorUpdateFailureErrorSchema

            return DeploymentConnectorUpdateFailureErrorSchema().load(data)
        if data["code"] == "DeploymentInvalidStatusTransition":
            from ._schemas.error import DeploymentInvalidStatusTransitionErrorSchema

            return DeploymentInvalidStatusTransitionErrorSchema().load(data)
        if data["code"] == "DeploymentUnknownApplicationConfiguration":
            from ._schemas.error import (
                DeploymentUnknownApplicationConfigurationErrorSchema,
            )

            return DeploymentUnknownApplicationConfigurationErrorSchema().load(data)
        if data["code"] == "DeploymentUnknownApplicationConfigurationKey":
            from ._schemas.error import (
                DeploymentUnknownApplicationConfigurationKeyErrorSchema,
            )

            return DeploymentUnknownApplicationConfigurationKeyErrorSchema().load(data)
        if data["code"] == "DeploymentUnsupportedRegion":
            from ._schemas.error import DeploymentUnsupportedRegionErrorSchema

            return DeploymentUnsupportedRegionErrorSchema().load(data)
        if data["code"] == "DeploymentApplicationDoNotBelong":
            from ._schemas.error import DeploymentApplicationDoNotBelongErrorSchema

            return DeploymentApplicationDoNotBelongErrorSchema().load(data)
        if data["code"] == "DeploymentApplicationRequired":
            from ._schemas.error import DeploymentApplicationRequiredErrorSchema

            return DeploymentApplicationRequiredErrorSchema().load(data)
        if data["code"] == "DeploymentMustIncludeApplication":
            from ._schemas.error import DeploymentMustIncludeApplicationErrorSchema

            return DeploymentMustIncludeApplicationErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import ErrorObjectSchema

        return ErrorObjectSchema().dump(self)


class ErrorResponse(_BaseType):
    """Base representation of an error response containing common fields to all errors."""

    #: HTTP status code corresponding to the error.
    status_code: int
    #: First error message in the `errors` array.
    message: str
    #: Errors returned for a request.
    #:
    #: A single error response can contain multiple errors if the errors are related to the same HTTP status code such as `400`.
    errors: typing.Optional[typing.List["ErrorObject"]]

    def __init__(
        self,
        *,
        status_code: int,
        message: str,
        errors: typing.Optional[typing.List["ErrorObject"]] = None
    ):
        self.status_code = status_code
        self.message = message
        self.errors = errors

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ErrorResponse":
        from ._schemas.error import ErrorResponseSchema

        return ErrorResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import ErrorResponseSchema

        return ErrorResponseSchema().dump(self)


class AuthenticationError(ErrorObject):
    """Returned when the client cannot be authenticated."""

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(message=message, code="AuthenticationError", **kwargs)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AuthenticationError":
        from ._schemas.error import AuthenticationErrorSchema

        return AuthenticationErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import AuthenticationErrorSchema

        return AuthenticationErrorSchema().dump(self)


class AuthorizationError(ErrorObject):
    """Returned when the client does not have sufficient permissions for this operation."""

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(message=message, code="AuthorizationError", **kwargs)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AuthorizationError":
        from ._schemas.error import AuthorizationErrorSchema

        return AuthorizationErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import AuthorizationErrorSchema

        return AuthorizationErrorSchema().dump(self)


class BadGatewayError(ErrorObject):
    """Returned when a server-side problem is caused by scaling infrastructure resources.

    The client application should retry the request with exponential backoff up to a point where further delay is unacceptable.

    """

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(message=message, code="BadGateway", **kwargs)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "BadGatewayError":
        from ._schemas.error import BadGatewayErrorSchema

        return BadGatewayErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import BadGatewayErrorSchema

        return BadGatewayErrorSchema().dump(self)


class ConcurrentModificationError(ErrorObject):
    """Returned when the request conflicts with the current state of the involved resources. Typically, the request attempts to modify a resource that is out of date (that is modified by another client since it was last retrieved).
    The client application should resolve the conflict (with or without involving the end-user) before retrying the request.

    """

    #: Expected version of the resource.
    expected_version: int
    #: Current version of the resource.
    current_version: typing.Optional[int]

    def __init__(
        self,
        *,
        message: str,
        expected_version: int,
        current_version: typing.Optional[int] = None,
        **kwargs
    ):
        self.expected_version = expected_version
        self.current_version = current_version
        kwargs.pop("code", None)
        super().__init__(message=message, code="ConcurrentModification", **kwargs)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConcurrentModificationError":
        from ._schemas.error import ConcurrentModificationErrorSchema

        return ConcurrentModificationErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import ConcurrentModificationErrorSchema

        return ConcurrentModificationErrorSchema().dump(self)


class DuplicateFieldError(ErrorObject):
    """Returned when a field value conflicts with an existing value causing a duplicate."""

    #: Name of the conflicting field.
    field: str
    #: Conflicting duplicate value.
    duplicate_value: typing.Any

    def __init__(
        self, *, message: str, field: str, duplicate_value: typing.Any, **kwargs
    ):
        self.field = field
        self.duplicate_value = duplicate_value
        kwargs.pop("code", None)
        super().__init__(message=message, code="DuplicateField", **kwargs)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DuplicateFieldError":
        from ._schemas.error import DuplicateFieldErrorSchema

        return DuplicateFieldErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import DuplicateFieldErrorSchema

        return DuplicateFieldErrorSchema().dump(self)


class FieldValueNotFoundError(ErrorObject):
    """Returned when a value for a field is not found."""

    #: Name of the field.
    field: str
    #: Conflicting value.
    value: typing.Any

    def __init__(self, *, message: str, field: str, value: typing.Any, **kwargs):
        self.field = field
        self.value = value
        kwargs.pop("code", None)
        super().__init__(message=message, code="FieldValueNotFound", **kwargs)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "FieldValueNotFoundError":
        from ._schemas.error import FieldValueNotFoundErrorSchema

        return FieldValueNotFoundErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import FieldValueNotFoundErrorSchema

        return FieldValueNotFoundErrorSchema().dump(self)


class GeneralError(ErrorObject):
    """Returned when a server-side problem occurs before or after data persistence. In some cases, the requested action may successfully complete after the error is returned. Therefore, it is recommended to verify the status of the requested resource after receiving a 500 error.

    If you encounter this error, report it to the [Connect support team](https://support.commercetools.com/).

    """

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(message=message, code="General", **kwargs)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "GeneralError":
        from ._schemas.error import GeneralErrorSchema

        return GeneralErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import GeneralErrorSchema

        return GeneralErrorSchema().dump(self)


class InvalidJsonInputError(ErrorObject):
    """Returned when an invalid JSON input has been sent.
    Either the JSON is syntactically incorrect or does not conform to the expected shape (for example is missing a required field).

    The client application should validate the input according to the constraints described in the error message before sending the request.

    """

    #: Further explanation about why the JSON is invalid.
    detailed_error_message: str

    def __init__(self, *, message: str, detailed_error_message: str, **kwargs):
        self.detailed_error_message = detailed_error_message
        kwargs.pop("code", None)
        super().__init__(message=message, code="InvalidJsonInput", **kwargs)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "InvalidJsonInputError":
        from ._schemas.error import InvalidJsonInputErrorSchema

        return InvalidJsonInputErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import InvalidJsonInputErrorSchema

        return InvalidJsonInputErrorSchema().dump(self)


class InvalidPathParamError(ErrorObject):
    """Returned when an invalid path parameter has been sent."""

    #: Further explanation about why the path parameter is invalid.
    detailed_error_message: str

    def __init__(self, *, message: str, detailed_error_message: str, **kwargs):
        self.detailed_error_message = detailed_error_message
        kwargs.pop("code", None)
        super().__init__(message=message, code="InvalidPathParam", **kwargs)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "InvalidPathParamError":
        from ._schemas.error import InvalidPathParamErrorSchema

        return InvalidPathParamErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import InvalidPathParamErrorSchema

        return InvalidPathParamErrorSchema().dump(self)


class InvalidQueryParamError(ErrorObject):
    """Returned when an invalid query parameter has been sent."""

    #: Further explanation about why the query parameter is invalid.
    detailed_error_message: str

    def __init__(self, *, message: str, detailed_error_message: str, **kwargs):
        self.detailed_error_message = detailed_error_message
        kwargs.pop("code", None)
        super().__init__(message=message, code="InvalidQueryParam", **kwargs)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "InvalidQueryParamError":
        from ._schemas.error import InvalidQueryParamErrorSchema

        return InvalidQueryParamErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import InvalidQueryParamErrorSchema

        return InvalidQueryParamErrorSchema().dump(self)


class ResourceNotFoundError(ErrorObject):
    """Returned when the resource addressed by the request URL does not exist."""

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(message=message, code="ResourceNotFound", **kwargs)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ResourceNotFoundError":
        from ._schemas.error import ResourceNotFoundErrorSchema

        return ResourceNotFoundErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import ResourceNotFoundErrorSchema

        return ResourceNotFoundErrorSchema().dump(self)


class ConnectorAlreadyCertifiedError(ErrorObject):
    """Returned when trying to certify a Connector that is already certified.

    The error is returned as a failed response to the [Publish](ctp:connect:type:ConnectorPublishAction) update action only when certification is required.

    """

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(message=message, code="ConnectorAlreadyCertified", **kwargs)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorAlreadyCertifiedError":
        from ._schemas.error import ConnectorAlreadyCertifiedErrorSchema

        return ConnectorAlreadyCertifiedErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import ConnectorAlreadyCertifiedErrorSchema

        return ConnectorAlreadyCertifiedErrorSchema().dump(self)


class ConnectorStagedInCertificationError(ErrorObject):
    """Returned when trying to publish a Connector that requires certification but is already in the certification process.

    The error is returned as a failed response to the [Publish](ctp:connect:type:ConnectorPublishAction) update actiononly when certification is required.

    """

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(
            message=message, code="ConnectorStagedInCertification", **kwargs
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorStagedInCertificationError":
        from ._schemas.error import ConnectorStagedInCertificationErrorSchema

        return ConnectorStagedInCertificationErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import ConnectorStagedInCertificationErrorSchema

        return ConnectorStagedInCertificationErrorSchema().dump(self)


class ConnectorStagedNotPreviewableError(ErrorObject):
    """Returned when a ConnectorStaged to be deployed is not previewable.

    The error is returned as a failed response to the [Create a Deployment](ctp:connect:endpoint:/{projectKey}/deployments:POST) request.

    """

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(
            message=message, code="ConnectorStagedNotPreviewable", **kwargs
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorStagedNotPreviewableError":
        from ._schemas.error import ConnectorStagedNotPreviewableErrorSchema

        return ConnectorStagedNotPreviewableErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import ConnectorStagedNotPreviewableErrorSchema

        return ConnectorStagedNotPreviewableErrorSchema().dump(self)


class ConnectorStagedNotPrivateError(ErrorObject):
    """Returned when attempting to change the `privateProjects` of a non-private ConnectorStaged.

    The error is returned as a failed response to the [Add Project to Private Connector](ctp:connect:type:ConnectorAddPrivateProjectAction) and [Remove Project from Private Connector](ctp:connect:type:ConnectorRemovePrivateProjectAction) update actions.

    """

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(message=message, code="ConnectorStagedNotPrivate", **kwargs)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorStagedNotPrivateError":
        from ._schemas.error import ConnectorStagedNotPrivateErrorSchema

        return ConnectorStagedNotPrivateErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import ConnectorStagedNotPrivateErrorSchema

        return ConnectorStagedNotPrivateErrorSchema().dump(self)


class ConnectorStagedPreviewRequestUnderProcessError(ErrorObject):
    """Returned when attempting to request previewable status of a ConnectorStaged that is currently being reviewed for previewable status.

    The error is returned as a failed response to the [Preview Connector](ctp:connect:type:ConnectorUpdatePreviewableAction) update action.

    """

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(
            message=message, code="ConnectorStagedPreviewRequestUnderProcess", **kwargs
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorStagedPreviewRequestUnderProcessError":
        from ._schemas.error import ConnectorStagedPreviewRequestUnderProcessErrorSchema

        return ConnectorStagedPreviewRequestUnderProcessErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import ConnectorStagedPreviewRequestUnderProcessErrorSchema

        return ConnectorStagedPreviewRequestUnderProcessErrorSchema().dump(self)


class GitRepositoryNotReachableError(ErrorObject):
    """Returned when the GitHub repository is unreachable or not found."""

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(message=message, code="GitRepositoryNotReachable", **kwargs)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "GitRepositoryNotReachableError":
        from ._schemas.error import GitRepositoryNotReachableErrorSchema

        return GitRepositoryNotReachableErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import GitRepositoryNotReachableErrorSchema

        return GitRepositoryNotReachableErrorSchema().dump(self)


class ConnectorSpecificationFileNotFoundError(ErrorObject):
    """Returned when the Connector specification file was not found."""

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(
            message=message, code="ConnectorSpecificationFileNotFound", **kwargs
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorSpecificationFileNotFoundError":
        from ._schemas.error import ConnectorSpecificationFileNotFoundErrorSchema

        return ConnectorSpecificationFileNotFoundErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import ConnectorSpecificationFileNotFoundErrorSchema

        return ConnectorSpecificationFileNotFoundErrorSchema().dump(self)


class ConnectorSpecificationFileNotValidError(ErrorObject):
    """Returned when the Connector specification file is not valid."""

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(
            message=message, code="ConnectorSpecificationFileNotValid", **kwargs
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorSpecificationFileNotValidError":
        from ._schemas.error import ConnectorSpecificationFileNotValidErrorSchema

        return ConnectorSpecificationFileNotValidErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import ConnectorSpecificationFileNotValidErrorSchema

        return ConnectorSpecificationFileNotValidErrorSchema().dump(self)


class ConnectorReferenceNotFoundError(ErrorObject):
    """Returned when the referenced Connector was not found."""

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(message=message, code="ConnectorReferenceNotFound", **kwargs)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ConnectorReferenceNotFoundError":
        from ._schemas.error import ConnectorReferenceNotFoundErrorSchema

        return ConnectorReferenceNotFoundErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import ConnectorReferenceNotFoundErrorSchema

        return ConnectorReferenceNotFoundErrorSchema().dump(self)


class DeploymentConnectorUpdateFailureError(ErrorObject):
    """Returned when updating a Connector fails during [redeployment](ctp:connect:type:DeploymentRedeploy)."""

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(
            message=message, code="DeploymentConnectorUpdateFailure", **kwargs
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DeploymentConnectorUpdateFailureError":
        from ._schemas.error import DeploymentConnectorUpdateFailureErrorSchema

        return DeploymentConnectorUpdateFailureErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import DeploymentConnectorUpdateFailureErrorSchema

        return DeploymentConnectorUpdateFailureErrorSchema().dump(self)


class DeploymentInvalidStatusTransitionError(ErrorObject):
    """Returned when the Deployment operation results in a invalid status transition.

    The error is returned as a failed response to the [Redeploy](ctp:connect:type:DeploymentRedeploy) update action.

    The message will contain `Already queued`, `Already deploying`, or `Already undeploying` based on the [DeploymentStatus](ctp:connect:type:DeploymentStatus) of the Deployment.

    """

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(
            message=message, code="DeploymentInvalidStatusTransition", **kwargs
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DeploymentInvalidStatusTransitionError":
        from ._schemas.error import DeploymentInvalidStatusTransitionErrorSchema

        return DeploymentInvalidStatusTransitionErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import DeploymentInvalidStatusTransitionErrorSchema

        return DeploymentInvalidStatusTransitionErrorSchema().dump(self)


class DeploymentUnknownApplicationConfigurationError(ErrorObject):
    """Returned when the Deployment contains configuration values that are not defined in the Connect application's connect.yaml file.

    The error is returned as a failed response to the [Redeploy](ctp:connect:type:DeploymentRedeploy) update action and [Create a Deployment](ctp:connect:endpoint:/{projectKey}/deployments:POST) request.

    """

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(
            message=message, code="DeploymentUnknownApplicationConfiguration", **kwargs
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DeploymentUnknownApplicationConfigurationError":
        from ._schemas.error import DeploymentUnknownApplicationConfigurationErrorSchema

        return DeploymentUnknownApplicationConfigurationErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import DeploymentUnknownApplicationConfigurationErrorSchema

        return DeploymentUnknownApplicationConfigurationErrorSchema().dump(self)


class DeploymentUnknownApplicationConfigurationKeyError(ErrorObject):
    """Returned when the Deployment contains a configuration key that is not defined in the Connect application's connect.yaml file.

    The error is returned as a failed response to the [Redeploy](ctp:connect:type:DeploymentRedeploy) update action and [Create a Deployment](ctp:connect:endpoint:/{projectKey}/deployments:POST) request.

    """

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(
            message=message,
            code="DeploymentUnknownApplicationConfigurationKey",
            **kwargs
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DeploymentUnknownApplicationConfigurationKeyError":
        from ._schemas.error import (
            DeploymentUnknownApplicationConfigurationKeyErrorSchema,
        )

        return DeploymentUnknownApplicationConfigurationKeyErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import (
            DeploymentUnknownApplicationConfigurationKeyErrorSchema,
        )

        return DeploymentUnknownApplicationConfigurationKeyErrorSchema().dump(self)


class DeploymentUnsupportedRegionError(ErrorObject):
    """Returned when the Deployment region is not supported.

    The error is returned as a failed response to the [Create a Deployment](ctp:connect:endpoint:/{projectKey}/deployments:POST) request.

    """

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(message=message, code="DeploymentUnsupportedRegion", **kwargs)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DeploymentUnsupportedRegionError":
        from ._schemas.error import DeploymentUnsupportedRegionErrorSchema

        return DeploymentUnsupportedRegionErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import DeploymentUnsupportedRegionErrorSchema

        return DeploymentUnsupportedRegionErrorSchema().dump(self)


class DeploymentApplicationDoNotBelongError(ErrorObject):
    """Returned when attempting to add an application that does not belong to the Deployment."""

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(
            message=message, code="DeploymentApplicationDoNotBelong", **kwargs
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DeploymentApplicationDoNotBelongError":
        from ._schemas.error import DeploymentApplicationDoNotBelongErrorSchema

        return DeploymentApplicationDoNotBelongErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import DeploymentApplicationDoNotBelongErrorSchema

        return DeploymentApplicationDoNotBelongErrorSchema().dump(self)


class DeploymentApplicationRequiredError(ErrorObject):
    """Returned when a Deployment does not contain any applications."""

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(
            message=message, code="DeploymentApplicationRequired", **kwargs
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DeploymentApplicationRequiredError":
        from ._schemas.error import DeploymentApplicationRequiredErrorSchema

        return DeploymentApplicationRequiredErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import DeploymentApplicationRequiredErrorSchema

        return DeploymentApplicationRequiredErrorSchema().dump(self)


class DeploymentMustIncludeApplicationError(ErrorObject):
    """Returned when attempting to remove an application that belongs to the Deployment."""

    def __init__(self, *, message: str, **kwargs):

        kwargs.pop("code", None)
        super().__init__(
            message=message, code="DeploymentMustIncludeApplication", **kwargs
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DeploymentMustIncludeApplicationError":
        from ._schemas.error import DeploymentMustIncludeApplicationErrorSchema

        return DeploymentMustIncludeApplicationErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.error import DeploymentMustIncludeApplicationErrorSchema

        return DeploymentMustIncludeApplicationErrorSchema().dump(self)
