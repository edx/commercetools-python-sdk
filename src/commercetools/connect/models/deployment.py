# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType

if typing.TYPE_CHECKING:
    from . import ConnectorReference, DeploymentConnector, DeploymentDetails
    from .common import ApplicationDeployment, DeploymentConfigurationApplication

__all__ = [
    "Deployment",
    "DeploymentDraft",
    "DeploymentLog",
    "DeploymentLogCursorPagedQueryResponse",
    "DeploymentPagedQueryResponse",
    "DeploymentRedeployAction",
    "DeploymentUpdate",
    "DeploymentUpdateAction",
]


class Deployment(_BaseType):
    #: Unique identifier of the Deployment.
    id: str
    #: User-defined unique identifier of the Deployment.
    key: typing.Optional[str]
    #: Current version of the Deployment.
    version: int
    #: Details of the [Connector](ctp:connect:type:Connector) being deployed.
    connector: "DeploymentConnector"
    #: Build reference id and outcome of the Deployment.
    details: "DeploymentDetails"
    #: Region of the Deployment.
    deployed_region: str
    #: Application deployments needed by the connector for hosting and configuration, refer to Connector configurations for details.
    applications: typing.List["ApplicationDeployment"]
    #: If `true`, the Deployment is a preview.
    preview: bool
    #: The current status of the Deployment.
    status: str

    def __init__(
        self,
        *,
        id: str,
        key: typing.Optional[str] = None,
        version: int,
        connector: "DeploymentConnector",
        details: "DeploymentDetails",
        deployed_region: str,
        applications: typing.List["ApplicationDeployment"],
        preview: bool,
        status: str
    ):
        self.id = id
        self.key = key
        self.version = version
        self.connector = connector
        self.details = details
        self.deployed_region = deployed_region
        self.applications = applications
        self.preview = preview
        self.status = status

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Deployment":
        from ._schemas.deployment import DeploymentSchema

        return DeploymentSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.deployment import DeploymentSchema

        return DeploymentSchema().dump(self)


class DeploymentPagedQueryResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) with results containing an array of [Deployment](ctp:connect:type:Deployment)."""

    #: The limit of the Deployments returned.
    limit: int
    #: The offset of the Deployments returned.
    offset: int
    #: The number of Deployments returned.
    count: int
    #: The total number of Deployments available.
    total: int
    #: Deployments matching the query.
    results: typing.List["Deployment"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: int,
        results: typing.List["Deployment"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DeploymentPagedQueryResponse":
        from ._schemas.deployment import DeploymentPagedQueryResponseSchema

        return DeploymentPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.deployment import DeploymentPagedQueryResponseSchema

        return DeploymentPagedQueryResponseSchema().dump(self)


class DeploymentDraft(_BaseType):
    #: User-defined unique identifier for the Deployment.
    key: typing.Optional[str]
    #: Reference to the [Connector](ctp:connect:type:Connector) or [ConnectorStaged](ctp:connect:type:ConnectorStaged) being deployed.
    connector: "ConnectorReference"
    #: Configuration values needed by the [Connector](ctp:connect:type:Connector) for hosting. Keys should match those in the Connector's `configurations` field.
    configurations: typing.Optional[typing.List["DeploymentConfigurationApplication"]]
    #: Region of Deployment.
    region: str

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        connector: "ConnectorReference",
        configurations: typing.Optional[
            typing.List["DeploymentConfigurationApplication"]
        ] = None,
        region: str
    ):
        self.key = key
        self.connector = connector
        self.configurations = configurations
        self.region = region

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DeploymentDraft":
        from ._schemas.deployment import DeploymentDraftSchema

        return DeploymentDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.deployment import DeploymentDraftSchema

        return DeploymentDraftSchema().dump(self)


class DeploymentUpdate(_BaseType):
    #: Expected version of the Deployment on which the changes apply.
    version: int
    #: Update actions to be performed on the Deployment.
    actions: typing.List["DeploymentUpdateAction"]

    def __init__(self, *, version: int, actions: typing.List["DeploymentUpdateAction"]):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DeploymentUpdate":
        from ._schemas.deployment import DeploymentUpdateSchema

        return DeploymentUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.deployment import DeploymentUpdateSchema

        return DeploymentUpdateSchema().dump(self)


class DeploymentUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DeploymentUpdateAction":
        if data["action"] == "redeploy":
            from ._schemas.deployment import DeploymentRedeployActionSchema

            return DeploymentRedeployActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.deployment import DeploymentUpdateActionSchema

        return DeploymentUpdateActionSchema().dump(self)


class DeploymentRedeployAction(DeploymentUpdateAction):
    """Updates configuration values and redeploys a Deployment in `Draft`, `Deployed`, `Failed`, or `UndeployFailed` states. The new configuration values must include at least one valid application. Ensure that all deployment configuration keys and values match those specified in the application's `connect.yaml` file.

    Specific error codes:
    - [DeploymentUnknownApplicationConfiguration](ctp:connect:type:DeploymentUnknownApplicationConfigurationError)
    - [DeploymentUnknownApplicationConfigurationKey](ctp:connect:type:DeploymentUnknownApplicationConfigurationKeyError)
    - [DeploymentInvalidStatusTransition](ctp:connect:type:DeploymentInvalidStatusTransitionError)
    - [DeploymentApplicationDoNotBelong](ctp:connect:type:DeploymentApplicationDoNotBelongError)
    - [DeploymentMustIncludeApplication](ctp:connect:type:DeploymentMustIncludeApplicationError)
    - [DeploymentConnectorUpdateFailure](ctp:connect:type:DeploymentConnectorUpdateFailureError)

    """

    #: Whether the scripts execution should be skipped during redeployment.
    skip_scripts: typing.Optional[bool]
    #: New configuration values for Deployment. If empty, any existing value is unchanged.
    configuration_values: typing.Optional[
        typing.List["DeploymentConfigurationApplication"]
    ]
    #: Whether the Deployment Connector should be updated to its latest state during redeployment.
    update_connector: typing.Optional[bool]

    def __init__(
        self,
        *,
        skip_scripts: typing.Optional[bool] = None,
        configuration_values: typing.Optional[
            typing.List["DeploymentConfigurationApplication"]
        ] = None,
        update_connector: typing.Optional[bool] = None
    ):
        self.skip_scripts = skip_scripts
        self.configuration_values = configuration_values
        self.update_connector = update_connector

        super().__init__(action="redeploy")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DeploymentRedeployAction":
        from ._schemas.deployment import DeploymentRedeployActionSchema

        return DeploymentRedeployActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.deployment import DeploymentRedeployActionSchema

        return DeploymentRedeployActionSchema().dump(self)


class DeploymentLog(_BaseType):
    """The data representation of a Deployment log."""

    type: str
    #: Unique identifier of the [Deployment](ctp:connect:type:Deployment).
    deployment_id: str
    #: Name of the Connect application.
    application_name: str
    #: Severity of the log message.
    severity: str
    #: Timestamp of the log message.
    timestamp: datetime.datetime
    #: Event details of the log message.
    details: typing.Any

    def __init__(
        self,
        *,
        type: str,
        deployment_id: str,
        application_name: str,
        severity: str,
        timestamp: datetime.datetime,
        details: typing.Any
    ):
        self.type = type
        self.deployment_id = deployment_id
        self.application_name = application_name
        self.severity = severity
        self.timestamp = timestamp
        self.details = details

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DeploymentLog":
        from ._schemas.deployment import DeploymentLogSchema

        return DeploymentLogSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.deployment import DeploymentLogSchema

        return DeploymentLogSchema().dump(self)


class DeploymentLogCursorPagedQueryResponse(_BaseType):
    """A cursor paged query result containing an array of [DeploymentLog](ctp:connect:type:DeploymentLog)."""

    #: Array of DeploymentLog objects.
    data: typing.List["DeploymentLog"]
    #: The next page token.
    next: str

    def __init__(self, *, data: typing.List["DeploymentLog"], next: str):
        self.data = data
        self.next = next

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DeploymentLogCursorPagedQueryResponse":
        from ._schemas.deployment import DeploymentLogCursorPagedQueryResponseSchema

        return DeploymentLogCursorPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.deployment import DeploymentLogCursorPagedQueryResponseSchema

        return DeploymentLogCursorPagedQueryResponseSchema().dump(self)
